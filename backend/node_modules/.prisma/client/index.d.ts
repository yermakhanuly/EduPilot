
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model StudyBlock
 * 
 */
export type StudyBlock = $Result.DefaultSelection<Prisma.$StudyBlockPayload>
/**
 * Model StudySession
 * 
 */
export type StudySession = $Result.DefaultSelection<Prisma.$StudySessionPayload>
/**
 * Model Reward
 * 
 */
export type Reward = $Result.DefaultSelection<Prisma.$RewardPayload>
/**
 * Model UserStats
 * 
 */
export type UserStats = $Result.DefaultSelection<Prisma.$UserStatsPayload>
/**
 * Model IntegrationCanvas
 * 
 */
export type IntegrationCanvas = $Result.DefaultSelection<Prisma.$IntegrationCanvasPayload>
/**
 * Model FixedEvent
 * 
 */
export type FixedEvent = $Result.DefaultSelection<Prisma.$FixedEventPayload>
/**
 * Model WeeklyClass
 * 
 */
export type WeeklyClass = $Result.DefaultSelection<Prisma.$WeeklyClassPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studyBlock`: Exposes CRUD operations for the **StudyBlock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudyBlocks
    * const studyBlocks = await prisma.studyBlock.findMany()
    * ```
    */
  get studyBlock(): Prisma.StudyBlockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studySession`: Exposes CRUD operations for the **StudySession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudySessions
    * const studySessions = await prisma.studySession.findMany()
    * ```
    */
  get studySession(): Prisma.StudySessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reward`: Exposes CRUD operations for the **Reward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rewards
    * const rewards = await prisma.reward.findMany()
    * ```
    */
  get reward(): Prisma.RewardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userStats`: Exposes CRUD operations for the **UserStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserStats
    * const userStats = await prisma.userStats.findMany()
    * ```
    */
  get userStats(): Prisma.UserStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.integrationCanvas`: Exposes CRUD operations for the **IntegrationCanvas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntegrationCanvas
    * const integrationCanvas = await prisma.integrationCanvas.findMany()
    * ```
    */
  get integrationCanvas(): Prisma.IntegrationCanvasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fixedEvent`: Exposes CRUD operations for the **FixedEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FixedEvents
    * const fixedEvents = await prisma.fixedEvent.findMany()
    * ```
    */
  get fixedEvent(): Prisma.FixedEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weeklyClass`: Exposes CRUD operations for the **WeeklyClass** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WeeklyClasses
    * const weeklyClasses = await prisma.weeklyClass.findMany()
    * ```
    */
  get weeklyClass(): Prisma.WeeklyClassDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.1
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Task: 'Task',
    StudyBlock: 'StudyBlock',
    StudySession: 'StudySession',
    Reward: 'Reward',
    UserStats: 'UserStats',
    IntegrationCanvas: 'IntegrationCanvas',
    FixedEvent: 'FixedEvent',
    WeeklyClass: 'WeeklyClass'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "task" | "studyBlock" | "studySession" | "reward" | "userStats" | "integrationCanvas" | "fixedEvent" | "weeklyClass"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      StudyBlock: {
        payload: Prisma.$StudyBlockPayload<ExtArgs>
        fields: Prisma.StudyBlockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudyBlockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyBlockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudyBlockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyBlockPayload>
          }
          findFirst: {
            args: Prisma.StudyBlockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyBlockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudyBlockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyBlockPayload>
          }
          findMany: {
            args: Prisma.StudyBlockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyBlockPayload>[]
          }
          create: {
            args: Prisma.StudyBlockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyBlockPayload>
          }
          createMany: {
            args: Prisma.StudyBlockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudyBlockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyBlockPayload>[]
          }
          delete: {
            args: Prisma.StudyBlockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyBlockPayload>
          }
          update: {
            args: Prisma.StudyBlockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyBlockPayload>
          }
          deleteMany: {
            args: Prisma.StudyBlockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudyBlockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudyBlockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyBlockPayload>[]
          }
          upsert: {
            args: Prisma.StudyBlockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyBlockPayload>
          }
          aggregate: {
            args: Prisma.StudyBlockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudyBlock>
          }
          groupBy: {
            args: Prisma.StudyBlockGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudyBlockGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudyBlockCountArgs<ExtArgs>
            result: $Utils.Optional<StudyBlockCountAggregateOutputType> | number
          }
        }
      }
      StudySession: {
        payload: Prisma.$StudySessionPayload<ExtArgs>
        fields: Prisma.StudySessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudySessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudySessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudySessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudySessionPayload>
          }
          findFirst: {
            args: Prisma.StudySessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudySessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudySessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudySessionPayload>
          }
          findMany: {
            args: Prisma.StudySessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudySessionPayload>[]
          }
          create: {
            args: Prisma.StudySessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudySessionPayload>
          }
          createMany: {
            args: Prisma.StudySessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudySessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudySessionPayload>[]
          }
          delete: {
            args: Prisma.StudySessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudySessionPayload>
          }
          update: {
            args: Prisma.StudySessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudySessionPayload>
          }
          deleteMany: {
            args: Prisma.StudySessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudySessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudySessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudySessionPayload>[]
          }
          upsert: {
            args: Prisma.StudySessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudySessionPayload>
          }
          aggregate: {
            args: Prisma.StudySessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudySession>
          }
          groupBy: {
            args: Prisma.StudySessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudySessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudySessionCountArgs<ExtArgs>
            result: $Utils.Optional<StudySessionCountAggregateOutputType> | number
          }
        }
      }
      Reward: {
        payload: Prisma.$RewardPayload<ExtArgs>
        fields: Prisma.RewardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RewardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RewardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          findFirst: {
            args: Prisma.RewardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RewardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          findMany: {
            args: Prisma.RewardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>[]
          }
          create: {
            args: Prisma.RewardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          createMany: {
            args: Prisma.RewardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RewardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>[]
          }
          delete: {
            args: Prisma.RewardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          update: {
            args: Prisma.RewardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          deleteMany: {
            args: Prisma.RewardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RewardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RewardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>[]
          }
          upsert: {
            args: Prisma.RewardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardPayload>
          }
          aggregate: {
            args: Prisma.RewardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReward>
          }
          groupBy: {
            args: Prisma.RewardGroupByArgs<ExtArgs>
            result: $Utils.Optional<RewardGroupByOutputType>[]
          }
          count: {
            args: Prisma.RewardCountArgs<ExtArgs>
            result: $Utils.Optional<RewardCountAggregateOutputType> | number
          }
        }
      }
      UserStats: {
        payload: Prisma.$UserStatsPayload<ExtArgs>
        fields: Prisma.UserStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          findFirst: {
            args: Prisma.UserStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          findMany: {
            args: Prisma.UserStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>[]
          }
          create: {
            args: Prisma.UserStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          createMany: {
            args: Prisma.UserStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>[]
          }
          delete: {
            args: Prisma.UserStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          update: {
            args: Prisma.UserStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          deleteMany: {
            args: Prisma.UserStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>[]
          }
          upsert: {
            args: Prisma.UserStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          aggregate: {
            args: Prisma.UserStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserStats>
          }
          groupBy: {
            args: Prisma.UserStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserStatsCountArgs<ExtArgs>
            result: $Utils.Optional<UserStatsCountAggregateOutputType> | number
          }
        }
      }
      IntegrationCanvas: {
        payload: Prisma.$IntegrationCanvasPayload<ExtArgs>
        fields: Prisma.IntegrationCanvasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntegrationCanvasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationCanvasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntegrationCanvasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationCanvasPayload>
          }
          findFirst: {
            args: Prisma.IntegrationCanvasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationCanvasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntegrationCanvasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationCanvasPayload>
          }
          findMany: {
            args: Prisma.IntegrationCanvasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationCanvasPayload>[]
          }
          create: {
            args: Prisma.IntegrationCanvasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationCanvasPayload>
          }
          createMany: {
            args: Prisma.IntegrationCanvasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntegrationCanvasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationCanvasPayload>[]
          }
          delete: {
            args: Prisma.IntegrationCanvasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationCanvasPayload>
          }
          update: {
            args: Prisma.IntegrationCanvasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationCanvasPayload>
          }
          deleteMany: {
            args: Prisma.IntegrationCanvasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntegrationCanvasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IntegrationCanvasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationCanvasPayload>[]
          }
          upsert: {
            args: Prisma.IntegrationCanvasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationCanvasPayload>
          }
          aggregate: {
            args: Prisma.IntegrationCanvasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntegrationCanvas>
          }
          groupBy: {
            args: Prisma.IntegrationCanvasGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntegrationCanvasGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntegrationCanvasCountArgs<ExtArgs>
            result: $Utils.Optional<IntegrationCanvasCountAggregateOutputType> | number
          }
        }
      }
      FixedEvent: {
        payload: Prisma.$FixedEventPayload<ExtArgs>
        fields: Prisma.FixedEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FixedEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixedEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FixedEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixedEventPayload>
          }
          findFirst: {
            args: Prisma.FixedEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixedEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FixedEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixedEventPayload>
          }
          findMany: {
            args: Prisma.FixedEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixedEventPayload>[]
          }
          create: {
            args: Prisma.FixedEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixedEventPayload>
          }
          createMany: {
            args: Prisma.FixedEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FixedEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixedEventPayload>[]
          }
          delete: {
            args: Prisma.FixedEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixedEventPayload>
          }
          update: {
            args: Prisma.FixedEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixedEventPayload>
          }
          deleteMany: {
            args: Prisma.FixedEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FixedEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FixedEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixedEventPayload>[]
          }
          upsert: {
            args: Prisma.FixedEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixedEventPayload>
          }
          aggregate: {
            args: Prisma.FixedEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFixedEvent>
          }
          groupBy: {
            args: Prisma.FixedEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<FixedEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.FixedEventCountArgs<ExtArgs>
            result: $Utils.Optional<FixedEventCountAggregateOutputType> | number
          }
        }
      }
      WeeklyClass: {
        payload: Prisma.$WeeklyClassPayload<ExtArgs>
        fields: Prisma.WeeklyClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeeklyClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeeklyClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyClassPayload>
          }
          findFirst: {
            args: Prisma.WeeklyClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeeklyClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyClassPayload>
          }
          findMany: {
            args: Prisma.WeeklyClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyClassPayload>[]
          }
          create: {
            args: Prisma.WeeklyClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyClassPayload>
          }
          createMany: {
            args: Prisma.WeeklyClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeeklyClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyClassPayload>[]
          }
          delete: {
            args: Prisma.WeeklyClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyClassPayload>
          }
          update: {
            args: Prisma.WeeklyClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyClassPayload>
          }
          deleteMany: {
            args: Prisma.WeeklyClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeeklyClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WeeklyClassUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyClassPayload>[]
          }
          upsert: {
            args: Prisma.WeeklyClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyClassPayload>
          }
          aggregate: {
            args: Prisma.WeeklyClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeeklyClass>
          }
          groupBy: {
            args: Prisma.WeeklyClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeeklyClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeeklyClassCountArgs<ExtArgs>
            result: $Utils.Optional<WeeklyClassCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    task?: TaskOmit
    studyBlock?: StudyBlockOmit
    studySession?: StudySessionOmit
    reward?: RewardOmit
    userStats?: UserStatsOmit
    integrationCanvas?: IntegrationCanvasOmit
    fixedEvent?: FixedEventOmit
    weeklyClass?: WeeklyClassOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    tasks: number
    studyBlocks: number
    studySessions: number
    rewards: number
    weeklyClasses: number
    fixedEvents: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | UserCountOutputTypeCountTasksArgs
    studyBlocks?: boolean | UserCountOutputTypeCountStudyBlocksArgs
    studySessions?: boolean | UserCountOutputTypeCountStudySessionsArgs
    rewards?: boolean | UserCountOutputTypeCountRewardsArgs
    weeklyClasses?: boolean | UserCountOutputTypeCountWeeklyClassesArgs
    fixedEvents?: boolean | UserCountOutputTypeCountFixedEventsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStudyBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudyBlockWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStudySessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudySessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWeeklyClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeeklyClassWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFixedEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FixedEventWhereInput
  }


  /**
   * Count Type TaskCountOutputType
   */

  export type TaskCountOutputType = {
    studyBlocks: number
    studySessions: number
  }

  export type TaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studyBlocks?: boolean | TaskCountOutputTypeCountStudyBlocksArgs
    studySessions?: boolean | TaskCountOutputTypeCountStudySessionsArgs
  }

  // Custom InputTypes
  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCountOutputType
     */
    select?: TaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountStudyBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudyBlockWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountStudySessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudySessionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    passwordHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    passwordHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    passwordHash: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    passwordHash: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tasks?: boolean | User$tasksArgs<ExtArgs>
    studyBlocks?: boolean | User$studyBlocksArgs<ExtArgs>
    studySessions?: boolean | User$studySessionsArgs<ExtArgs>
    rewards?: boolean | User$rewardsArgs<ExtArgs>
    stats?: boolean | User$statsArgs<ExtArgs>
    integrationCanvas?: boolean | User$integrationCanvasArgs<ExtArgs>
    weeklyClasses?: boolean | User$weeklyClassesArgs<ExtArgs>
    fixedEvents?: boolean | User$fixedEventsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "passwordHash" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | User$tasksArgs<ExtArgs>
    studyBlocks?: boolean | User$studyBlocksArgs<ExtArgs>
    studySessions?: boolean | User$studySessionsArgs<ExtArgs>
    rewards?: boolean | User$rewardsArgs<ExtArgs>
    stats?: boolean | User$statsArgs<ExtArgs>
    integrationCanvas?: boolean | User$integrationCanvasArgs<ExtArgs>
    weeklyClasses?: boolean | User$weeklyClassesArgs<ExtArgs>
    fixedEvents?: boolean | User$fixedEventsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      studyBlocks: Prisma.$StudyBlockPayload<ExtArgs>[]
      studySessions: Prisma.$StudySessionPayload<ExtArgs>[]
      rewards: Prisma.$RewardPayload<ExtArgs>[]
      stats: Prisma.$UserStatsPayload<ExtArgs> | null
      integrationCanvas: Prisma.$IntegrationCanvasPayload<ExtArgs> | null
      weeklyClasses: Prisma.$WeeklyClassPayload<ExtArgs>[]
      fixedEvents: Prisma.$FixedEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      passwordHash: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tasks<T extends User$tasksArgs<ExtArgs> = {}>(args?: Subset<T, User$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studyBlocks<T extends User$studyBlocksArgs<ExtArgs> = {}>(args?: Subset<T, User$studyBlocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyBlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studySessions<T extends User$studySessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$studySessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudySessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rewards<T extends User$rewardsArgs<ExtArgs> = {}>(args?: Subset<T, User$rewardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stats<T extends User$statsArgs<ExtArgs> = {}>(args?: Subset<T, User$statsArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    integrationCanvas<T extends User$integrationCanvasArgs<ExtArgs> = {}>(args?: Subset<T, User$integrationCanvasArgs<ExtArgs>>): Prisma__IntegrationCanvasClient<$Result.GetResult<Prisma.$IntegrationCanvasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    weeklyClasses<T extends User$weeklyClassesArgs<ExtArgs> = {}>(args?: Subset<T, User$weeklyClassesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklyClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fixedEvents<T extends User$fixedEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$fixedEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FixedEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.tasks
   */
  export type User$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * User.studyBlocks
   */
  export type User$studyBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyBlock
     */
    select?: StudyBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyBlock
     */
    omit?: StudyBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyBlockInclude<ExtArgs> | null
    where?: StudyBlockWhereInput
    orderBy?: StudyBlockOrderByWithRelationInput | StudyBlockOrderByWithRelationInput[]
    cursor?: StudyBlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudyBlockScalarFieldEnum | StudyBlockScalarFieldEnum[]
  }

  /**
   * User.studySessions
   */
  export type User$studySessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudySession
     */
    omit?: StudySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionInclude<ExtArgs> | null
    where?: StudySessionWhereInput
    orderBy?: StudySessionOrderByWithRelationInput | StudySessionOrderByWithRelationInput[]
    cursor?: StudySessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudySessionScalarFieldEnum | StudySessionScalarFieldEnum[]
  }

  /**
   * User.rewards
   */
  export type User$rewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    where?: RewardWhereInput
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[]
    cursor?: RewardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
  }

  /**
   * User.stats
   */
  export type User$statsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    where?: UserStatsWhereInput
  }

  /**
   * User.integrationCanvas
   */
  export type User$integrationCanvasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationCanvas
     */
    select?: IntegrationCanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationCanvas
     */
    omit?: IntegrationCanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationCanvasInclude<ExtArgs> | null
    where?: IntegrationCanvasWhereInput
  }

  /**
   * User.weeklyClasses
   */
  export type User$weeklyClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyClass
     */
    select?: WeeklyClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyClass
     */
    omit?: WeeklyClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyClassInclude<ExtArgs> | null
    where?: WeeklyClassWhereInput
    orderBy?: WeeklyClassOrderByWithRelationInput | WeeklyClassOrderByWithRelationInput[]
    cursor?: WeeklyClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeeklyClassScalarFieldEnum | WeeklyClassScalarFieldEnum[]
  }

  /**
   * User.fixedEvents
   */
  export type User$fixedEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixedEvent
     */
    select?: FixedEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FixedEvent
     */
    omit?: FixedEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixedEventInclude<ExtArgs> | null
    where?: FixedEventWhereInput
    orderBy?: FixedEventOrderByWithRelationInput | FixedEventOrderByWithRelationInput[]
    cursor?: FixedEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FixedEventScalarFieldEnum | FixedEventScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    priority: number | null
    remainingHours: number | null
  }

  export type TaskSumAggregateOutputType = {
    priority: number | null
    remainingHours: number | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    deadline: Date | null
    difficulty: string | null
    priority: number | null
    remainingHours: number | null
    status: string | null
    source: string | null
    externalId: string | null
    completedAt: Date | null
    completionXpAwarded: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    deadline: Date | null
    difficulty: string | null
    priority: number | null
    remainingHours: number | null
    status: string | null
    source: string | null
    externalId: string | null
    completedAt: Date | null
    completionXpAwarded: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    description: number
    deadline: number
    difficulty: number
    priority: number
    remainingHours: number
    status: number
    source: number
    externalId: number
    completedAt: number
    completionXpAwarded: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    priority?: true
    remainingHours?: true
  }

  export type TaskSumAggregateInputType = {
    priority?: true
    remainingHours?: true
  }

  export type TaskMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    deadline?: true
    difficulty?: true
    priority?: true
    remainingHours?: true
    status?: true
    source?: true
    externalId?: true
    completedAt?: true
    completionXpAwarded?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    deadline?: true
    difficulty?: true
    priority?: true
    remainingHours?: true
    status?: true
    source?: true
    externalId?: true
    completedAt?: true
    completionXpAwarded?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    deadline?: true
    difficulty?: true
    priority?: true
    remainingHours?: true
    status?: true
    source?: true
    externalId?: true
    completedAt?: true
    completionXpAwarded?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    userId: string
    title: string
    description: string | null
    deadline: Date | null
    difficulty: string
    priority: number
    remainingHours: number
    status: string
    source: string
    externalId: string | null
    completedAt: Date | null
    completionXpAwarded: boolean
    createdAt: Date
    updatedAt: Date
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    deadline?: boolean
    difficulty?: boolean
    priority?: boolean
    remainingHours?: boolean
    status?: boolean
    source?: boolean
    externalId?: boolean
    completedAt?: boolean
    completionXpAwarded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    studyBlocks?: boolean | Task$studyBlocksArgs<ExtArgs>
    studySessions?: boolean | Task$studySessionsArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    deadline?: boolean
    difficulty?: boolean
    priority?: boolean
    remainingHours?: boolean
    status?: boolean
    source?: boolean
    externalId?: boolean
    completedAt?: boolean
    completionXpAwarded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    deadline?: boolean
    difficulty?: boolean
    priority?: boolean
    remainingHours?: boolean
    status?: boolean
    source?: boolean
    externalId?: boolean
    completedAt?: boolean
    completionXpAwarded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    deadline?: boolean
    difficulty?: boolean
    priority?: boolean
    remainingHours?: boolean
    status?: boolean
    source?: boolean
    externalId?: boolean
    completedAt?: boolean
    completionXpAwarded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "description" | "deadline" | "difficulty" | "priority" | "remainingHours" | "status" | "source" | "externalId" | "completedAt" | "completionXpAwarded" | "createdAt" | "updatedAt", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    studyBlocks?: boolean | Task$studyBlocksArgs<ExtArgs>
    studySessions?: boolean | Task$studySessionsArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      studyBlocks: Prisma.$StudyBlockPayload<ExtArgs>[]
      studySessions: Prisma.$StudySessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      description: string | null
      deadline: Date | null
      difficulty: string
      priority: number
      remainingHours: number
      status: string
      source: string
      externalId: string | null
      completedAt: Date | null
      completionXpAwarded: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    studyBlocks<T extends Task$studyBlocksArgs<ExtArgs> = {}>(args?: Subset<T, Task$studyBlocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyBlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studySessions<T extends Task$studySessionsArgs<ExtArgs> = {}>(args?: Subset<T, Task$studySessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudySessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly userId: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly deadline: FieldRef<"Task", 'DateTime'>
    readonly difficulty: FieldRef<"Task", 'String'>
    readonly priority: FieldRef<"Task", 'Int'>
    readonly remainingHours: FieldRef<"Task", 'Int'>
    readonly status: FieldRef<"Task", 'String'>
    readonly source: FieldRef<"Task", 'String'>
    readonly externalId: FieldRef<"Task", 'String'>
    readonly completedAt: FieldRef<"Task", 'DateTime'>
    readonly completionXpAwarded: FieldRef<"Task", 'Boolean'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task updateManyAndReturn
   */
  export type TaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task.studyBlocks
   */
  export type Task$studyBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyBlock
     */
    select?: StudyBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyBlock
     */
    omit?: StudyBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyBlockInclude<ExtArgs> | null
    where?: StudyBlockWhereInput
    orderBy?: StudyBlockOrderByWithRelationInput | StudyBlockOrderByWithRelationInput[]
    cursor?: StudyBlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudyBlockScalarFieldEnum | StudyBlockScalarFieldEnum[]
  }

  /**
   * Task.studySessions
   */
  export type Task$studySessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudySession
     */
    omit?: StudySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionInclude<ExtArgs> | null
    where?: StudySessionWhereInput
    orderBy?: StudySessionOrderByWithRelationInput | StudySessionOrderByWithRelationInput[]
    cursor?: StudySessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudySessionScalarFieldEnum | StudySessionScalarFieldEnum[]
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model StudyBlock
   */

  export type AggregateStudyBlock = {
    _count: StudyBlockCountAggregateOutputType | null
    _min: StudyBlockMinAggregateOutputType | null
    _max: StudyBlockMaxAggregateOutputType | null
  }

  export type StudyBlockMinAggregateOutputType = {
    id: string | null
    userId: string | null
    taskId: string | null
    start: Date | null
    end: Date | null
    source: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudyBlockMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    taskId: string | null
    start: Date | null
    end: Date | null
    source: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudyBlockCountAggregateOutputType = {
    id: number
    userId: number
    taskId: number
    start: number
    end: number
    source: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudyBlockMinAggregateInputType = {
    id?: true
    userId?: true
    taskId?: true
    start?: true
    end?: true
    source?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudyBlockMaxAggregateInputType = {
    id?: true
    userId?: true
    taskId?: true
    start?: true
    end?: true
    source?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudyBlockCountAggregateInputType = {
    id?: true
    userId?: true
    taskId?: true
    start?: true
    end?: true
    source?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudyBlockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudyBlock to aggregate.
     */
    where?: StudyBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyBlocks to fetch.
     */
    orderBy?: StudyBlockOrderByWithRelationInput | StudyBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudyBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudyBlocks
    **/
    _count?: true | StudyBlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudyBlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudyBlockMaxAggregateInputType
  }

  export type GetStudyBlockAggregateType<T extends StudyBlockAggregateArgs> = {
        [P in keyof T & keyof AggregateStudyBlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudyBlock[P]>
      : GetScalarType<T[P], AggregateStudyBlock[P]>
  }




  export type StudyBlockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudyBlockWhereInput
    orderBy?: StudyBlockOrderByWithAggregationInput | StudyBlockOrderByWithAggregationInput[]
    by: StudyBlockScalarFieldEnum[] | StudyBlockScalarFieldEnum
    having?: StudyBlockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudyBlockCountAggregateInputType | true
    _min?: StudyBlockMinAggregateInputType
    _max?: StudyBlockMaxAggregateInputType
  }

  export type StudyBlockGroupByOutputType = {
    id: string
    userId: string
    taskId: string | null
    start: Date
    end: Date
    source: string
    status: string
    createdAt: Date
    updatedAt: Date
    _count: StudyBlockCountAggregateOutputType | null
    _min: StudyBlockMinAggregateOutputType | null
    _max: StudyBlockMaxAggregateOutputType | null
  }

  type GetStudyBlockGroupByPayload<T extends StudyBlockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudyBlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudyBlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudyBlockGroupByOutputType[P]>
            : GetScalarType<T[P], StudyBlockGroupByOutputType[P]>
        }
      >
    >


  export type StudyBlockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    taskId?: boolean
    start?: boolean
    end?: boolean
    source?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    task?: boolean | StudyBlock$taskArgs<ExtArgs>
    studySession?: boolean | StudyBlock$studySessionArgs<ExtArgs>
  }, ExtArgs["result"]["studyBlock"]>

  export type StudyBlockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    taskId?: boolean
    start?: boolean
    end?: boolean
    source?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    task?: boolean | StudyBlock$taskArgs<ExtArgs>
  }, ExtArgs["result"]["studyBlock"]>

  export type StudyBlockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    taskId?: boolean
    start?: boolean
    end?: boolean
    source?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    task?: boolean | StudyBlock$taskArgs<ExtArgs>
  }, ExtArgs["result"]["studyBlock"]>

  export type StudyBlockSelectScalar = {
    id?: boolean
    userId?: boolean
    taskId?: boolean
    start?: boolean
    end?: boolean
    source?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudyBlockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "taskId" | "start" | "end" | "source" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["studyBlock"]>
  export type StudyBlockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    task?: boolean | StudyBlock$taskArgs<ExtArgs>
    studySession?: boolean | StudyBlock$studySessionArgs<ExtArgs>
  }
  export type StudyBlockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    task?: boolean | StudyBlock$taskArgs<ExtArgs>
  }
  export type StudyBlockIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    task?: boolean | StudyBlock$taskArgs<ExtArgs>
  }

  export type $StudyBlockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudyBlock"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      task: Prisma.$TaskPayload<ExtArgs> | null
      studySession: Prisma.$StudySessionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      taskId: string | null
      start: Date
      end: Date
      source: string
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studyBlock"]>
    composites: {}
  }

  type StudyBlockGetPayload<S extends boolean | null | undefined | StudyBlockDefaultArgs> = $Result.GetResult<Prisma.$StudyBlockPayload, S>

  type StudyBlockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudyBlockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudyBlockCountAggregateInputType | true
    }

  export interface StudyBlockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudyBlock'], meta: { name: 'StudyBlock' } }
    /**
     * Find zero or one StudyBlock that matches the filter.
     * @param {StudyBlockFindUniqueArgs} args - Arguments to find a StudyBlock
     * @example
     * // Get one StudyBlock
     * const studyBlock = await prisma.studyBlock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudyBlockFindUniqueArgs>(args: SelectSubset<T, StudyBlockFindUniqueArgs<ExtArgs>>): Prisma__StudyBlockClient<$Result.GetResult<Prisma.$StudyBlockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudyBlock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudyBlockFindUniqueOrThrowArgs} args - Arguments to find a StudyBlock
     * @example
     * // Get one StudyBlock
     * const studyBlock = await prisma.studyBlock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudyBlockFindUniqueOrThrowArgs>(args: SelectSubset<T, StudyBlockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudyBlockClient<$Result.GetResult<Prisma.$StudyBlockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudyBlock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyBlockFindFirstArgs} args - Arguments to find a StudyBlock
     * @example
     * // Get one StudyBlock
     * const studyBlock = await prisma.studyBlock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudyBlockFindFirstArgs>(args?: SelectSubset<T, StudyBlockFindFirstArgs<ExtArgs>>): Prisma__StudyBlockClient<$Result.GetResult<Prisma.$StudyBlockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudyBlock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyBlockFindFirstOrThrowArgs} args - Arguments to find a StudyBlock
     * @example
     * // Get one StudyBlock
     * const studyBlock = await prisma.studyBlock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudyBlockFindFirstOrThrowArgs>(args?: SelectSubset<T, StudyBlockFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudyBlockClient<$Result.GetResult<Prisma.$StudyBlockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudyBlocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyBlockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudyBlocks
     * const studyBlocks = await prisma.studyBlock.findMany()
     * 
     * // Get first 10 StudyBlocks
     * const studyBlocks = await prisma.studyBlock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studyBlockWithIdOnly = await prisma.studyBlock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudyBlockFindManyArgs>(args?: SelectSubset<T, StudyBlockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyBlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudyBlock.
     * @param {StudyBlockCreateArgs} args - Arguments to create a StudyBlock.
     * @example
     * // Create one StudyBlock
     * const StudyBlock = await prisma.studyBlock.create({
     *   data: {
     *     // ... data to create a StudyBlock
     *   }
     * })
     * 
     */
    create<T extends StudyBlockCreateArgs>(args: SelectSubset<T, StudyBlockCreateArgs<ExtArgs>>): Prisma__StudyBlockClient<$Result.GetResult<Prisma.$StudyBlockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudyBlocks.
     * @param {StudyBlockCreateManyArgs} args - Arguments to create many StudyBlocks.
     * @example
     * // Create many StudyBlocks
     * const studyBlock = await prisma.studyBlock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudyBlockCreateManyArgs>(args?: SelectSubset<T, StudyBlockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudyBlocks and returns the data saved in the database.
     * @param {StudyBlockCreateManyAndReturnArgs} args - Arguments to create many StudyBlocks.
     * @example
     * // Create many StudyBlocks
     * const studyBlock = await prisma.studyBlock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudyBlocks and only return the `id`
     * const studyBlockWithIdOnly = await prisma.studyBlock.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudyBlockCreateManyAndReturnArgs>(args?: SelectSubset<T, StudyBlockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyBlockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudyBlock.
     * @param {StudyBlockDeleteArgs} args - Arguments to delete one StudyBlock.
     * @example
     * // Delete one StudyBlock
     * const StudyBlock = await prisma.studyBlock.delete({
     *   where: {
     *     // ... filter to delete one StudyBlock
     *   }
     * })
     * 
     */
    delete<T extends StudyBlockDeleteArgs>(args: SelectSubset<T, StudyBlockDeleteArgs<ExtArgs>>): Prisma__StudyBlockClient<$Result.GetResult<Prisma.$StudyBlockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudyBlock.
     * @param {StudyBlockUpdateArgs} args - Arguments to update one StudyBlock.
     * @example
     * // Update one StudyBlock
     * const studyBlock = await prisma.studyBlock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudyBlockUpdateArgs>(args: SelectSubset<T, StudyBlockUpdateArgs<ExtArgs>>): Prisma__StudyBlockClient<$Result.GetResult<Prisma.$StudyBlockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudyBlocks.
     * @param {StudyBlockDeleteManyArgs} args - Arguments to filter StudyBlocks to delete.
     * @example
     * // Delete a few StudyBlocks
     * const { count } = await prisma.studyBlock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudyBlockDeleteManyArgs>(args?: SelectSubset<T, StudyBlockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudyBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyBlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudyBlocks
     * const studyBlock = await prisma.studyBlock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudyBlockUpdateManyArgs>(args: SelectSubset<T, StudyBlockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudyBlocks and returns the data updated in the database.
     * @param {StudyBlockUpdateManyAndReturnArgs} args - Arguments to update many StudyBlocks.
     * @example
     * // Update many StudyBlocks
     * const studyBlock = await prisma.studyBlock.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudyBlocks and only return the `id`
     * const studyBlockWithIdOnly = await prisma.studyBlock.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudyBlockUpdateManyAndReturnArgs>(args: SelectSubset<T, StudyBlockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyBlockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudyBlock.
     * @param {StudyBlockUpsertArgs} args - Arguments to update or create a StudyBlock.
     * @example
     * // Update or create a StudyBlock
     * const studyBlock = await prisma.studyBlock.upsert({
     *   create: {
     *     // ... data to create a StudyBlock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudyBlock we want to update
     *   }
     * })
     */
    upsert<T extends StudyBlockUpsertArgs>(args: SelectSubset<T, StudyBlockUpsertArgs<ExtArgs>>): Prisma__StudyBlockClient<$Result.GetResult<Prisma.$StudyBlockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudyBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyBlockCountArgs} args - Arguments to filter StudyBlocks to count.
     * @example
     * // Count the number of StudyBlocks
     * const count = await prisma.studyBlock.count({
     *   where: {
     *     // ... the filter for the StudyBlocks we want to count
     *   }
     * })
    **/
    count<T extends StudyBlockCountArgs>(
      args?: Subset<T, StudyBlockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudyBlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudyBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyBlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudyBlockAggregateArgs>(args: Subset<T, StudyBlockAggregateArgs>): Prisma.PrismaPromise<GetStudyBlockAggregateType<T>>

    /**
     * Group by StudyBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyBlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudyBlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudyBlockGroupByArgs['orderBy'] }
        : { orderBy?: StudyBlockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudyBlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudyBlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudyBlock model
   */
  readonly fields: StudyBlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudyBlock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudyBlockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    task<T extends StudyBlock$taskArgs<ExtArgs> = {}>(args?: Subset<T, StudyBlock$taskArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    studySession<T extends StudyBlock$studySessionArgs<ExtArgs> = {}>(args?: Subset<T, StudyBlock$studySessionArgs<ExtArgs>>): Prisma__StudySessionClient<$Result.GetResult<Prisma.$StudySessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudyBlock model
   */
  interface StudyBlockFieldRefs {
    readonly id: FieldRef<"StudyBlock", 'String'>
    readonly userId: FieldRef<"StudyBlock", 'String'>
    readonly taskId: FieldRef<"StudyBlock", 'String'>
    readonly start: FieldRef<"StudyBlock", 'DateTime'>
    readonly end: FieldRef<"StudyBlock", 'DateTime'>
    readonly source: FieldRef<"StudyBlock", 'String'>
    readonly status: FieldRef<"StudyBlock", 'String'>
    readonly createdAt: FieldRef<"StudyBlock", 'DateTime'>
    readonly updatedAt: FieldRef<"StudyBlock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudyBlock findUnique
   */
  export type StudyBlockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyBlock
     */
    select?: StudyBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyBlock
     */
    omit?: StudyBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyBlockInclude<ExtArgs> | null
    /**
     * Filter, which StudyBlock to fetch.
     */
    where: StudyBlockWhereUniqueInput
  }

  /**
   * StudyBlock findUniqueOrThrow
   */
  export type StudyBlockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyBlock
     */
    select?: StudyBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyBlock
     */
    omit?: StudyBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyBlockInclude<ExtArgs> | null
    /**
     * Filter, which StudyBlock to fetch.
     */
    where: StudyBlockWhereUniqueInput
  }

  /**
   * StudyBlock findFirst
   */
  export type StudyBlockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyBlock
     */
    select?: StudyBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyBlock
     */
    omit?: StudyBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyBlockInclude<ExtArgs> | null
    /**
     * Filter, which StudyBlock to fetch.
     */
    where?: StudyBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyBlocks to fetch.
     */
    orderBy?: StudyBlockOrderByWithRelationInput | StudyBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudyBlocks.
     */
    cursor?: StudyBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudyBlocks.
     */
    distinct?: StudyBlockScalarFieldEnum | StudyBlockScalarFieldEnum[]
  }

  /**
   * StudyBlock findFirstOrThrow
   */
  export type StudyBlockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyBlock
     */
    select?: StudyBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyBlock
     */
    omit?: StudyBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyBlockInclude<ExtArgs> | null
    /**
     * Filter, which StudyBlock to fetch.
     */
    where?: StudyBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyBlocks to fetch.
     */
    orderBy?: StudyBlockOrderByWithRelationInput | StudyBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudyBlocks.
     */
    cursor?: StudyBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudyBlocks.
     */
    distinct?: StudyBlockScalarFieldEnum | StudyBlockScalarFieldEnum[]
  }

  /**
   * StudyBlock findMany
   */
  export type StudyBlockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyBlock
     */
    select?: StudyBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyBlock
     */
    omit?: StudyBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyBlockInclude<ExtArgs> | null
    /**
     * Filter, which StudyBlocks to fetch.
     */
    where?: StudyBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyBlocks to fetch.
     */
    orderBy?: StudyBlockOrderByWithRelationInput | StudyBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudyBlocks.
     */
    cursor?: StudyBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyBlocks.
     */
    skip?: number
    distinct?: StudyBlockScalarFieldEnum | StudyBlockScalarFieldEnum[]
  }

  /**
   * StudyBlock create
   */
  export type StudyBlockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyBlock
     */
    select?: StudyBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyBlock
     */
    omit?: StudyBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyBlockInclude<ExtArgs> | null
    /**
     * The data needed to create a StudyBlock.
     */
    data: XOR<StudyBlockCreateInput, StudyBlockUncheckedCreateInput>
  }

  /**
   * StudyBlock createMany
   */
  export type StudyBlockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudyBlocks.
     */
    data: StudyBlockCreateManyInput | StudyBlockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudyBlock createManyAndReturn
   */
  export type StudyBlockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyBlock
     */
    select?: StudyBlockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudyBlock
     */
    omit?: StudyBlockOmit<ExtArgs> | null
    /**
     * The data used to create many StudyBlocks.
     */
    data: StudyBlockCreateManyInput | StudyBlockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyBlockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudyBlock update
   */
  export type StudyBlockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyBlock
     */
    select?: StudyBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyBlock
     */
    omit?: StudyBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyBlockInclude<ExtArgs> | null
    /**
     * The data needed to update a StudyBlock.
     */
    data: XOR<StudyBlockUpdateInput, StudyBlockUncheckedUpdateInput>
    /**
     * Choose, which StudyBlock to update.
     */
    where: StudyBlockWhereUniqueInput
  }

  /**
   * StudyBlock updateMany
   */
  export type StudyBlockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudyBlocks.
     */
    data: XOR<StudyBlockUpdateManyMutationInput, StudyBlockUncheckedUpdateManyInput>
    /**
     * Filter which StudyBlocks to update
     */
    where?: StudyBlockWhereInput
    /**
     * Limit how many StudyBlocks to update.
     */
    limit?: number
  }

  /**
   * StudyBlock updateManyAndReturn
   */
  export type StudyBlockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyBlock
     */
    select?: StudyBlockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudyBlock
     */
    omit?: StudyBlockOmit<ExtArgs> | null
    /**
     * The data used to update StudyBlocks.
     */
    data: XOR<StudyBlockUpdateManyMutationInput, StudyBlockUncheckedUpdateManyInput>
    /**
     * Filter which StudyBlocks to update
     */
    where?: StudyBlockWhereInput
    /**
     * Limit how many StudyBlocks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyBlockIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudyBlock upsert
   */
  export type StudyBlockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyBlock
     */
    select?: StudyBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyBlock
     */
    omit?: StudyBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyBlockInclude<ExtArgs> | null
    /**
     * The filter to search for the StudyBlock to update in case it exists.
     */
    where: StudyBlockWhereUniqueInput
    /**
     * In case the StudyBlock found by the `where` argument doesn't exist, create a new StudyBlock with this data.
     */
    create: XOR<StudyBlockCreateInput, StudyBlockUncheckedCreateInput>
    /**
     * In case the StudyBlock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudyBlockUpdateInput, StudyBlockUncheckedUpdateInput>
  }

  /**
   * StudyBlock delete
   */
  export type StudyBlockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyBlock
     */
    select?: StudyBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyBlock
     */
    omit?: StudyBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyBlockInclude<ExtArgs> | null
    /**
     * Filter which StudyBlock to delete.
     */
    where: StudyBlockWhereUniqueInput
  }

  /**
   * StudyBlock deleteMany
   */
  export type StudyBlockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudyBlocks to delete
     */
    where?: StudyBlockWhereInput
    /**
     * Limit how many StudyBlocks to delete.
     */
    limit?: number
  }

  /**
   * StudyBlock.task
   */
  export type StudyBlock$taskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
  }

  /**
   * StudyBlock.studySession
   */
  export type StudyBlock$studySessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudySession
     */
    omit?: StudySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionInclude<ExtArgs> | null
    where?: StudySessionWhereInput
  }

  /**
   * StudyBlock without action
   */
  export type StudyBlockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyBlock
     */
    select?: StudyBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyBlock
     */
    omit?: StudyBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyBlockInclude<ExtArgs> | null
  }


  /**
   * Model StudySession
   */

  export type AggregateStudySession = {
    _count: StudySessionCountAggregateOutputType | null
    _avg: StudySessionAvgAggregateOutputType | null
    _sum: StudySessionSumAggregateOutputType | null
    _min: StudySessionMinAggregateOutputType | null
    _max: StudySessionMaxAggregateOutputType | null
  }

  export type StudySessionAvgAggregateOutputType = {
    focusedMinutes: number | null
    xpEarned: number | null
  }

  export type StudySessionSumAggregateOutputType = {
    focusedMinutes: number | null
    xpEarned: number | null
  }

  export type StudySessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    taskId: string | null
    blockId: string | null
    startedAt: Date | null
    endedAt: Date | null
    status: string | null
    focusedMinutes: number | null
    xpEarned: number | null
  }

  export type StudySessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    taskId: string | null
    blockId: string | null
    startedAt: Date | null
    endedAt: Date | null
    status: string | null
    focusedMinutes: number | null
    xpEarned: number | null
  }

  export type StudySessionCountAggregateOutputType = {
    id: number
    userId: number
    taskId: number
    blockId: number
    startedAt: number
    endedAt: number
    status: number
    focusedMinutes: number
    xpEarned: number
    _all: number
  }


  export type StudySessionAvgAggregateInputType = {
    focusedMinutes?: true
    xpEarned?: true
  }

  export type StudySessionSumAggregateInputType = {
    focusedMinutes?: true
    xpEarned?: true
  }

  export type StudySessionMinAggregateInputType = {
    id?: true
    userId?: true
    taskId?: true
    blockId?: true
    startedAt?: true
    endedAt?: true
    status?: true
    focusedMinutes?: true
    xpEarned?: true
  }

  export type StudySessionMaxAggregateInputType = {
    id?: true
    userId?: true
    taskId?: true
    blockId?: true
    startedAt?: true
    endedAt?: true
    status?: true
    focusedMinutes?: true
    xpEarned?: true
  }

  export type StudySessionCountAggregateInputType = {
    id?: true
    userId?: true
    taskId?: true
    blockId?: true
    startedAt?: true
    endedAt?: true
    status?: true
    focusedMinutes?: true
    xpEarned?: true
    _all?: true
  }

  export type StudySessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudySession to aggregate.
     */
    where?: StudySessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudySessions to fetch.
     */
    orderBy?: StudySessionOrderByWithRelationInput | StudySessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudySessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudySessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudySessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudySessions
    **/
    _count?: true | StudySessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudySessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudySessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudySessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudySessionMaxAggregateInputType
  }

  export type GetStudySessionAggregateType<T extends StudySessionAggregateArgs> = {
        [P in keyof T & keyof AggregateStudySession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudySession[P]>
      : GetScalarType<T[P], AggregateStudySession[P]>
  }




  export type StudySessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudySessionWhereInput
    orderBy?: StudySessionOrderByWithAggregationInput | StudySessionOrderByWithAggregationInput[]
    by: StudySessionScalarFieldEnum[] | StudySessionScalarFieldEnum
    having?: StudySessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudySessionCountAggregateInputType | true
    _avg?: StudySessionAvgAggregateInputType
    _sum?: StudySessionSumAggregateInputType
    _min?: StudySessionMinAggregateInputType
    _max?: StudySessionMaxAggregateInputType
  }

  export type StudySessionGroupByOutputType = {
    id: string
    userId: string
    taskId: string | null
    blockId: string | null
    startedAt: Date
    endedAt: Date | null
    status: string
    focusedMinutes: number
    xpEarned: number
    _count: StudySessionCountAggregateOutputType | null
    _avg: StudySessionAvgAggregateOutputType | null
    _sum: StudySessionSumAggregateOutputType | null
    _min: StudySessionMinAggregateOutputType | null
    _max: StudySessionMaxAggregateOutputType | null
  }

  type GetStudySessionGroupByPayload<T extends StudySessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudySessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudySessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudySessionGroupByOutputType[P]>
            : GetScalarType<T[P], StudySessionGroupByOutputType[P]>
        }
      >
    >


  export type StudySessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    taskId?: boolean
    blockId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    focusedMinutes?: boolean
    xpEarned?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    task?: boolean | StudySession$taskArgs<ExtArgs>
    block?: boolean | StudySession$blockArgs<ExtArgs>
  }, ExtArgs["result"]["studySession"]>

  export type StudySessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    taskId?: boolean
    blockId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    focusedMinutes?: boolean
    xpEarned?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    task?: boolean | StudySession$taskArgs<ExtArgs>
    block?: boolean | StudySession$blockArgs<ExtArgs>
  }, ExtArgs["result"]["studySession"]>

  export type StudySessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    taskId?: boolean
    blockId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    focusedMinutes?: boolean
    xpEarned?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    task?: boolean | StudySession$taskArgs<ExtArgs>
    block?: boolean | StudySession$blockArgs<ExtArgs>
  }, ExtArgs["result"]["studySession"]>

  export type StudySessionSelectScalar = {
    id?: boolean
    userId?: boolean
    taskId?: boolean
    blockId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    focusedMinutes?: boolean
    xpEarned?: boolean
  }

  export type StudySessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "taskId" | "blockId" | "startedAt" | "endedAt" | "status" | "focusedMinutes" | "xpEarned", ExtArgs["result"]["studySession"]>
  export type StudySessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    task?: boolean | StudySession$taskArgs<ExtArgs>
    block?: boolean | StudySession$blockArgs<ExtArgs>
  }
  export type StudySessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    task?: boolean | StudySession$taskArgs<ExtArgs>
    block?: boolean | StudySession$blockArgs<ExtArgs>
  }
  export type StudySessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    task?: boolean | StudySession$taskArgs<ExtArgs>
    block?: boolean | StudySession$blockArgs<ExtArgs>
  }

  export type $StudySessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudySession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      task: Prisma.$TaskPayload<ExtArgs> | null
      block: Prisma.$StudyBlockPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      taskId: string | null
      blockId: string | null
      startedAt: Date
      endedAt: Date | null
      status: string
      focusedMinutes: number
      xpEarned: number
    }, ExtArgs["result"]["studySession"]>
    composites: {}
  }

  type StudySessionGetPayload<S extends boolean | null | undefined | StudySessionDefaultArgs> = $Result.GetResult<Prisma.$StudySessionPayload, S>

  type StudySessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudySessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudySessionCountAggregateInputType | true
    }

  export interface StudySessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudySession'], meta: { name: 'StudySession' } }
    /**
     * Find zero or one StudySession that matches the filter.
     * @param {StudySessionFindUniqueArgs} args - Arguments to find a StudySession
     * @example
     * // Get one StudySession
     * const studySession = await prisma.studySession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudySessionFindUniqueArgs>(args: SelectSubset<T, StudySessionFindUniqueArgs<ExtArgs>>): Prisma__StudySessionClient<$Result.GetResult<Prisma.$StudySessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudySession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudySessionFindUniqueOrThrowArgs} args - Arguments to find a StudySession
     * @example
     * // Get one StudySession
     * const studySession = await prisma.studySession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudySessionFindUniqueOrThrowArgs>(args: SelectSubset<T, StudySessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudySessionClient<$Result.GetResult<Prisma.$StudySessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudySession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudySessionFindFirstArgs} args - Arguments to find a StudySession
     * @example
     * // Get one StudySession
     * const studySession = await prisma.studySession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudySessionFindFirstArgs>(args?: SelectSubset<T, StudySessionFindFirstArgs<ExtArgs>>): Prisma__StudySessionClient<$Result.GetResult<Prisma.$StudySessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudySession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudySessionFindFirstOrThrowArgs} args - Arguments to find a StudySession
     * @example
     * // Get one StudySession
     * const studySession = await prisma.studySession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudySessionFindFirstOrThrowArgs>(args?: SelectSubset<T, StudySessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudySessionClient<$Result.GetResult<Prisma.$StudySessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudySessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudySessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudySessions
     * const studySessions = await prisma.studySession.findMany()
     * 
     * // Get first 10 StudySessions
     * const studySessions = await prisma.studySession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studySessionWithIdOnly = await prisma.studySession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudySessionFindManyArgs>(args?: SelectSubset<T, StudySessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudySessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudySession.
     * @param {StudySessionCreateArgs} args - Arguments to create a StudySession.
     * @example
     * // Create one StudySession
     * const StudySession = await prisma.studySession.create({
     *   data: {
     *     // ... data to create a StudySession
     *   }
     * })
     * 
     */
    create<T extends StudySessionCreateArgs>(args: SelectSubset<T, StudySessionCreateArgs<ExtArgs>>): Prisma__StudySessionClient<$Result.GetResult<Prisma.$StudySessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudySessions.
     * @param {StudySessionCreateManyArgs} args - Arguments to create many StudySessions.
     * @example
     * // Create many StudySessions
     * const studySession = await prisma.studySession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudySessionCreateManyArgs>(args?: SelectSubset<T, StudySessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudySessions and returns the data saved in the database.
     * @param {StudySessionCreateManyAndReturnArgs} args - Arguments to create many StudySessions.
     * @example
     * // Create many StudySessions
     * const studySession = await prisma.studySession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudySessions and only return the `id`
     * const studySessionWithIdOnly = await prisma.studySession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudySessionCreateManyAndReturnArgs>(args?: SelectSubset<T, StudySessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudySessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudySession.
     * @param {StudySessionDeleteArgs} args - Arguments to delete one StudySession.
     * @example
     * // Delete one StudySession
     * const StudySession = await prisma.studySession.delete({
     *   where: {
     *     // ... filter to delete one StudySession
     *   }
     * })
     * 
     */
    delete<T extends StudySessionDeleteArgs>(args: SelectSubset<T, StudySessionDeleteArgs<ExtArgs>>): Prisma__StudySessionClient<$Result.GetResult<Prisma.$StudySessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudySession.
     * @param {StudySessionUpdateArgs} args - Arguments to update one StudySession.
     * @example
     * // Update one StudySession
     * const studySession = await prisma.studySession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudySessionUpdateArgs>(args: SelectSubset<T, StudySessionUpdateArgs<ExtArgs>>): Prisma__StudySessionClient<$Result.GetResult<Prisma.$StudySessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudySessions.
     * @param {StudySessionDeleteManyArgs} args - Arguments to filter StudySessions to delete.
     * @example
     * // Delete a few StudySessions
     * const { count } = await prisma.studySession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudySessionDeleteManyArgs>(args?: SelectSubset<T, StudySessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudySessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudySessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudySessions
     * const studySession = await prisma.studySession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudySessionUpdateManyArgs>(args: SelectSubset<T, StudySessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudySessions and returns the data updated in the database.
     * @param {StudySessionUpdateManyAndReturnArgs} args - Arguments to update many StudySessions.
     * @example
     * // Update many StudySessions
     * const studySession = await prisma.studySession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudySessions and only return the `id`
     * const studySessionWithIdOnly = await prisma.studySession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudySessionUpdateManyAndReturnArgs>(args: SelectSubset<T, StudySessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudySessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudySession.
     * @param {StudySessionUpsertArgs} args - Arguments to update or create a StudySession.
     * @example
     * // Update or create a StudySession
     * const studySession = await prisma.studySession.upsert({
     *   create: {
     *     // ... data to create a StudySession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudySession we want to update
     *   }
     * })
     */
    upsert<T extends StudySessionUpsertArgs>(args: SelectSubset<T, StudySessionUpsertArgs<ExtArgs>>): Prisma__StudySessionClient<$Result.GetResult<Prisma.$StudySessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudySessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudySessionCountArgs} args - Arguments to filter StudySessions to count.
     * @example
     * // Count the number of StudySessions
     * const count = await prisma.studySession.count({
     *   where: {
     *     // ... the filter for the StudySessions we want to count
     *   }
     * })
    **/
    count<T extends StudySessionCountArgs>(
      args?: Subset<T, StudySessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudySessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudySession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudySessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudySessionAggregateArgs>(args: Subset<T, StudySessionAggregateArgs>): Prisma.PrismaPromise<GetStudySessionAggregateType<T>>

    /**
     * Group by StudySession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudySessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudySessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudySessionGroupByArgs['orderBy'] }
        : { orderBy?: StudySessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudySessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudySessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudySession model
   */
  readonly fields: StudySessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudySession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudySessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    task<T extends StudySession$taskArgs<ExtArgs> = {}>(args?: Subset<T, StudySession$taskArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    block<T extends StudySession$blockArgs<ExtArgs> = {}>(args?: Subset<T, StudySession$blockArgs<ExtArgs>>): Prisma__StudyBlockClient<$Result.GetResult<Prisma.$StudyBlockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudySession model
   */
  interface StudySessionFieldRefs {
    readonly id: FieldRef<"StudySession", 'String'>
    readonly userId: FieldRef<"StudySession", 'String'>
    readonly taskId: FieldRef<"StudySession", 'String'>
    readonly blockId: FieldRef<"StudySession", 'String'>
    readonly startedAt: FieldRef<"StudySession", 'DateTime'>
    readonly endedAt: FieldRef<"StudySession", 'DateTime'>
    readonly status: FieldRef<"StudySession", 'String'>
    readonly focusedMinutes: FieldRef<"StudySession", 'Int'>
    readonly xpEarned: FieldRef<"StudySession", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * StudySession findUnique
   */
  export type StudySessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudySession
     */
    omit?: StudySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionInclude<ExtArgs> | null
    /**
     * Filter, which StudySession to fetch.
     */
    where: StudySessionWhereUniqueInput
  }

  /**
   * StudySession findUniqueOrThrow
   */
  export type StudySessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudySession
     */
    omit?: StudySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionInclude<ExtArgs> | null
    /**
     * Filter, which StudySession to fetch.
     */
    where: StudySessionWhereUniqueInput
  }

  /**
   * StudySession findFirst
   */
  export type StudySessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudySession
     */
    omit?: StudySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionInclude<ExtArgs> | null
    /**
     * Filter, which StudySession to fetch.
     */
    where?: StudySessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudySessions to fetch.
     */
    orderBy?: StudySessionOrderByWithRelationInput | StudySessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudySessions.
     */
    cursor?: StudySessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudySessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudySessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudySessions.
     */
    distinct?: StudySessionScalarFieldEnum | StudySessionScalarFieldEnum[]
  }

  /**
   * StudySession findFirstOrThrow
   */
  export type StudySessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudySession
     */
    omit?: StudySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionInclude<ExtArgs> | null
    /**
     * Filter, which StudySession to fetch.
     */
    where?: StudySessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudySessions to fetch.
     */
    orderBy?: StudySessionOrderByWithRelationInput | StudySessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudySessions.
     */
    cursor?: StudySessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudySessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudySessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudySessions.
     */
    distinct?: StudySessionScalarFieldEnum | StudySessionScalarFieldEnum[]
  }

  /**
   * StudySession findMany
   */
  export type StudySessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudySession
     */
    omit?: StudySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionInclude<ExtArgs> | null
    /**
     * Filter, which StudySessions to fetch.
     */
    where?: StudySessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudySessions to fetch.
     */
    orderBy?: StudySessionOrderByWithRelationInput | StudySessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudySessions.
     */
    cursor?: StudySessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudySessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudySessions.
     */
    skip?: number
    distinct?: StudySessionScalarFieldEnum | StudySessionScalarFieldEnum[]
  }

  /**
   * StudySession create
   */
  export type StudySessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudySession
     */
    omit?: StudySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionInclude<ExtArgs> | null
    /**
     * The data needed to create a StudySession.
     */
    data: XOR<StudySessionCreateInput, StudySessionUncheckedCreateInput>
  }

  /**
   * StudySession createMany
   */
  export type StudySessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudySessions.
     */
    data: StudySessionCreateManyInput | StudySessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudySession createManyAndReturn
   */
  export type StudySessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudySession
     */
    omit?: StudySessionOmit<ExtArgs> | null
    /**
     * The data used to create many StudySessions.
     */
    data: StudySessionCreateManyInput | StudySessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudySession update
   */
  export type StudySessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudySession
     */
    omit?: StudySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionInclude<ExtArgs> | null
    /**
     * The data needed to update a StudySession.
     */
    data: XOR<StudySessionUpdateInput, StudySessionUncheckedUpdateInput>
    /**
     * Choose, which StudySession to update.
     */
    where: StudySessionWhereUniqueInput
  }

  /**
   * StudySession updateMany
   */
  export type StudySessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudySessions.
     */
    data: XOR<StudySessionUpdateManyMutationInput, StudySessionUncheckedUpdateManyInput>
    /**
     * Filter which StudySessions to update
     */
    where?: StudySessionWhereInput
    /**
     * Limit how many StudySessions to update.
     */
    limit?: number
  }

  /**
   * StudySession updateManyAndReturn
   */
  export type StudySessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudySession
     */
    omit?: StudySessionOmit<ExtArgs> | null
    /**
     * The data used to update StudySessions.
     */
    data: XOR<StudySessionUpdateManyMutationInput, StudySessionUncheckedUpdateManyInput>
    /**
     * Filter which StudySessions to update
     */
    where?: StudySessionWhereInput
    /**
     * Limit how many StudySessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudySession upsert
   */
  export type StudySessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudySession
     */
    omit?: StudySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionInclude<ExtArgs> | null
    /**
     * The filter to search for the StudySession to update in case it exists.
     */
    where: StudySessionWhereUniqueInput
    /**
     * In case the StudySession found by the `where` argument doesn't exist, create a new StudySession with this data.
     */
    create: XOR<StudySessionCreateInput, StudySessionUncheckedCreateInput>
    /**
     * In case the StudySession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudySessionUpdateInput, StudySessionUncheckedUpdateInput>
  }

  /**
   * StudySession delete
   */
  export type StudySessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudySession
     */
    omit?: StudySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionInclude<ExtArgs> | null
    /**
     * Filter which StudySession to delete.
     */
    where: StudySessionWhereUniqueInput
  }

  /**
   * StudySession deleteMany
   */
  export type StudySessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudySessions to delete
     */
    where?: StudySessionWhereInput
    /**
     * Limit how many StudySessions to delete.
     */
    limit?: number
  }

  /**
   * StudySession.task
   */
  export type StudySession$taskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
  }

  /**
   * StudySession.block
   */
  export type StudySession$blockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyBlock
     */
    select?: StudyBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyBlock
     */
    omit?: StudyBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyBlockInclude<ExtArgs> | null
    where?: StudyBlockWhereInput
  }

  /**
   * StudySession without action
   */
  export type StudySessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudySession
     */
    omit?: StudySessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionInclude<ExtArgs> | null
  }


  /**
   * Model Reward
   */

  export type AggregateReward = {
    _count: RewardCountAggregateOutputType | null
    _avg: RewardAvgAggregateOutputType | null
    _sum: RewardSumAggregateOutputType | null
    _min: RewardMinAggregateOutputType | null
    _max: RewardMaxAggregateOutputType | null
  }

  export type RewardAvgAggregateOutputType = {
    costXp: number | null
  }

  export type RewardSumAggregateOutputType = {
    costXp: number | null
  }

  export type RewardMinAggregateOutputType = {
    id: string | null
    userId: string | null
    label: string | null
    detail: string | null
    costXp: number | null
    claimedAt: Date | null
  }

  export type RewardMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    label: string | null
    detail: string | null
    costXp: number | null
    claimedAt: Date | null
  }

  export type RewardCountAggregateOutputType = {
    id: number
    userId: number
    label: number
    detail: number
    costXp: number
    claimedAt: number
    _all: number
  }


  export type RewardAvgAggregateInputType = {
    costXp?: true
  }

  export type RewardSumAggregateInputType = {
    costXp?: true
  }

  export type RewardMinAggregateInputType = {
    id?: true
    userId?: true
    label?: true
    detail?: true
    costXp?: true
    claimedAt?: true
  }

  export type RewardMaxAggregateInputType = {
    id?: true
    userId?: true
    label?: true
    detail?: true
    costXp?: true
    claimedAt?: true
  }

  export type RewardCountAggregateInputType = {
    id?: true
    userId?: true
    label?: true
    detail?: true
    costXp?: true
    claimedAt?: true
    _all?: true
  }

  export type RewardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reward to aggregate.
     */
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rewards
    **/
    _count?: true | RewardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RewardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RewardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardMaxAggregateInputType
  }

  export type GetRewardAggregateType<T extends RewardAggregateArgs> = {
        [P in keyof T & keyof AggregateReward]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReward[P]>
      : GetScalarType<T[P], AggregateReward[P]>
  }




  export type RewardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardWhereInput
    orderBy?: RewardOrderByWithAggregationInput | RewardOrderByWithAggregationInput[]
    by: RewardScalarFieldEnum[] | RewardScalarFieldEnum
    having?: RewardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardCountAggregateInputType | true
    _avg?: RewardAvgAggregateInputType
    _sum?: RewardSumAggregateInputType
    _min?: RewardMinAggregateInputType
    _max?: RewardMaxAggregateInputType
  }

  export type RewardGroupByOutputType = {
    id: string
    userId: string
    label: string
    detail: string | null
    costXp: number
    claimedAt: Date | null
    _count: RewardCountAggregateOutputType | null
    _avg: RewardAvgAggregateOutputType | null
    _sum: RewardSumAggregateOutputType | null
    _min: RewardMinAggregateOutputType | null
    _max: RewardMaxAggregateOutputType | null
  }

  type GetRewardGroupByPayload<T extends RewardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RewardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardGroupByOutputType[P]>
            : GetScalarType<T[P], RewardGroupByOutputType[P]>
        }
      >
    >


  export type RewardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    label?: boolean
    detail?: boolean
    costXp?: boolean
    claimedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reward"]>

  export type RewardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    label?: boolean
    detail?: boolean
    costXp?: boolean
    claimedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reward"]>

  export type RewardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    label?: boolean
    detail?: boolean
    costXp?: boolean
    claimedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reward"]>

  export type RewardSelectScalar = {
    id?: boolean
    userId?: boolean
    label?: boolean
    detail?: boolean
    costXp?: boolean
    claimedAt?: boolean
  }

  export type RewardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "label" | "detail" | "costXp" | "claimedAt", ExtArgs["result"]["reward"]>
  export type RewardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RewardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RewardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RewardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reward"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      label: string
      detail: string | null
      costXp: number
      claimedAt: Date | null
    }, ExtArgs["result"]["reward"]>
    composites: {}
  }

  type RewardGetPayload<S extends boolean | null | undefined | RewardDefaultArgs> = $Result.GetResult<Prisma.$RewardPayload, S>

  type RewardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RewardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RewardCountAggregateInputType | true
    }

  export interface RewardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reward'], meta: { name: 'Reward' } }
    /**
     * Find zero or one Reward that matches the filter.
     * @param {RewardFindUniqueArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RewardFindUniqueArgs>(args: SelectSubset<T, RewardFindUniqueArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reward that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RewardFindUniqueOrThrowArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RewardFindUniqueOrThrowArgs>(args: SelectSubset<T, RewardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardFindFirstArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RewardFindFirstArgs>(args?: SelectSubset<T, RewardFindFirstArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reward that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardFindFirstOrThrowArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RewardFindFirstOrThrowArgs>(args?: SelectSubset<T, RewardFindFirstOrThrowArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rewards
     * const rewards = await prisma.reward.findMany()
     * 
     * // Get first 10 Rewards
     * const rewards = await prisma.reward.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rewardWithIdOnly = await prisma.reward.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RewardFindManyArgs>(args?: SelectSubset<T, RewardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reward.
     * @param {RewardCreateArgs} args - Arguments to create a Reward.
     * @example
     * // Create one Reward
     * const Reward = await prisma.reward.create({
     *   data: {
     *     // ... data to create a Reward
     *   }
     * })
     * 
     */
    create<T extends RewardCreateArgs>(args: SelectSubset<T, RewardCreateArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rewards.
     * @param {RewardCreateManyArgs} args - Arguments to create many Rewards.
     * @example
     * // Create many Rewards
     * const reward = await prisma.reward.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RewardCreateManyArgs>(args?: SelectSubset<T, RewardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rewards and returns the data saved in the database.
     * @param {RewardCreateManyAndReturnArgs} args - Arguments to create many Rewards.
     * @example
     * // Create many Rewards
     * const reward = await prisma.reward.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rewards and only return the `id`
     * const rewardWithIdOnly = await prisma.reward.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RewardCreateManyAndReturnArgs>(args?: SelectSubset<T, RewardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reward.
     * @param {RewardDeleteArgs} args - Arguments to delete one Reward.
     * @example
     * // Delete one Reward
     * const Reward = await prisma.reward.delete({
     *   where: {
     *     // ... filter to delete one Reward
     *   }
     * })
     * 
     */
    delete<T extends RewardDeleteArgs>(args: SelectSubset<T, RewardDeleteArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reward.
     * @param {RewardUpdateArgs} args - Arguments to update one Reward.
     * @example
     * // Update one Reward
     * const reward = await prisma.reward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RewardUpdateArgs>(args: SelectSubset<T, RewardUpdateArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rewards.
     * @param {RewardDeleteManyArgs} args - Arguments to filter Rewards to delete.
     * @example
     * // Delete a few Rewards
     * const { count } = await prisma.reward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RewardDeleteManyArgs>(args?: SelectSubset<T, RewardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rewards
     * const reward = await prisma.reward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RewardUpdateManyArgs>(args: SelectSubset<T, RewardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rewards and returns the data updated in the database.
     * @param {RewardUpdateManyAndReturnArgs} args - Arguments to update many Rewards.
     * @example
     * // Update many Rewards
     * const reward = await prisma.reward.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rewards and only return the `id`
     * const rewardWithIdOnly = await prisma.reward.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RewardUpdateManyAndReturnArgs>(args: SelectSubset<T, RewardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reward.
     * @param {RewardUpsertArgs} args - Arguments to update or create a Reward.
     * @example
     * // Update or create a Reward
     * const reward = await prisma.reward.upsert({
     *   create: {
     *     // ... data to create a Reward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reward we want to update
     *   }
     * })
     */
    upsert<T extends RewardUpsertArgs>(args: SelectSubset<T, RewardUpsertArgs<ExtArgs>>): Prisma__RewardClient<$Result.GetResult<Prisma.$RewardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardCountArgs} args - Arguments to filter Rewards to count.
     * @example
     * // Count the number of Rewards
     * const count = await prisma.reward.count({
     *   where: {
     *     // ... the filter for the Rewards we want to count
     *   }
     * })
    **/
    count<T extends RewardCountArgs>(
      args?: Subset<T, RewardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardAggregateArgs>(args: Subset<T, RewardAggregateArgs>): Prisma.PrismaPromise<GetRewardAggregateType<T>>

    /**
     * Group by Reward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RewardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RewardGroupByArgs['orderBy'] }
        : { orderBy?: RewardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RewardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reward model
   */
  readonly fields: RewardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RewardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reward model
   */
  interface RewardFieldRefs {
    readonly id: FieldRef<"Reward", 'String'>
    readonly userId: FieldRef<"Reward", 'String'>
    readonly label: FieldRef<"Reward", 'String'>
    readonly detail: FieldRef<"Reward", 'String'>
    readonly costXp: FieldRef<"Reward", 'Int'>
    readonly claimedAt: FieldRef<"Reward", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reward findUnique
   */
  export type RewardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter, which Reward to fetch.
     */
    where: RewardWhereUniqueInput
  }

  /**
   * Reward findUniqueOrThrow
   */
  export type RewardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter, which Reward to fetch.
     */
    where: RewardWhereUniqueInput
  }

  /**
   * Reward findFirst
   */
  export type RewardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter, which Reward to fetch.
     */
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rewards.
     */
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rewards.
     */
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
  }

  /**
   * Reward findFirstOrThrow
   */
  export type RewardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter, which Reward to fetch.
     */
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rewards.
     */
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rewards.
     */
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
  }

  /**
   * Reward findMany
   */
  export type RewardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter, which Rewards to fetch.
     */
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: RewardOrderByWithRelationInput | RewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rewards.
     */
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
  }

  /**
   * Reward create
   */
  export type RewardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * The data needed to create a Reward.
     */
    data: XOR<RewardCreateInput, RewardUncheckedCreateInput>
  }

  /**
   * Reward createMany
   */
  export type RewardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rewards.
     */
    data: RewardCreateManyInput | RewardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reward createManyAndReturn
   */
  export type RewardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * The data used to create many Rewards.
     */
    data: RewardCreateManyInput | RewardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reward update
   */
  export type RewardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * The data needed to update a Reward.
     */
    data: XOR<RewardUpdateInput, RewardUncheckedUpdateInput>
    /**
     * Choose, which Reward to update.
     */
    where: RewardWhereUniqueInput
  }

  /**
   * Reward updateMany
   */
  export type RewardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rewards.
     */
    data: XOR<RewardUpdateManyMutationInput, RewardUncheckedUpdateManyInput>
    /**
     * Filter which Rewards to update
     */
    where?: RewardWhereInput
    /**
     * Limit how many Rewards to update.
     */
    limit?: number
  }

  /**
   * Reward updateManyAndReturn
   */
  export type RewardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * The data used to update Rewards.
     */
    data: XOR<RewardUpdateManyMutationInput, RewardUncheckedUpdateManyInput>
    /**
     * Filter which Rewards to update
     */
    where?: RewardWhereInput
    /**
     * Limit how many Rewards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reward upsert
   */
  export type RewardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * The filter to search for the Reward to update in case it exists.
     */
    where: RewardWhereUniqueInput
    /**
     * In case the Reward found by the `where` argument doesn't exist, create a new Reward with this data.
     */
    create: XOR<RewardCreateInput, RewardUncheckedCreateInput>
    /**
     * In case the Reward was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RewardUpdateInput, RewardUncheckedUpdateInput>
  }

  /**
   * Reward delete
   */
  export type RewardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
    /**
     * Filter which Reward to delete.
     */
    where: RewardWhereUniqueInput
  }

  /**
   * Reward deleteMany
   */
  export type RewardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rewards to delete
     */
    where?: RewardWhereInput
    /**
     * Limit how many Rewards to delete.
     */
    limit?: number
  }

  /**
   * Reward without action
   */
  export type RewardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reward
     */
    omit?: RewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardInclude<ExtArgs> | null
  }


  /**
   * Model UserStats
   */

  export type AggregateUserStats = {
    _count: UserStatsCountAggregateOutputType | null
    _avg: UserStatsAvgAggregateOutputType | null
    _sum: UserStatsSumAggregateOutputType | null
    _min: UserStatsMinAggregateOutputType | null
    _max: UserStatsMaxAggregateOutputType | null
  }

  export type UserStatsAvgAggregateOutputType = {
    totalXp: number | null
    weeklyXp: number | null
    streak: number | null
    level: number | null
    dailyBaseXp: number | null
    dailyXp: number | null
  }

  export type UserStatsSumAggregateOutputType = {
    totalXp: number | null
    weeklyXp: number | null
    streak: number | null
    level: number | null
    dailyBaseXp: number | null
    dailyXp: number | null
  }

  export type UserStatsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    totalXp: number | null
    weeklyXp: number | null
    streak: number | null
    level: number | null
    dailyBaseXp: number | null
    dailyXp: number | null
    dailyDate: Date | null
    lastSessionAt: Date | null
  }

  export type UserStatsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    totalXp: number | null
    weeklyXp: number | null
    streak: number | null
    level: number | null
    dailyBaseXp: number | null
    dailyXp: number | null
    dailyDate: Date | null
    lastSessionAt: Date | null
  }

  export type UserStatsCountAggregateOutputType = {
    id: number
    userId: number
    totalXp: number
    weeklyXp: number
    streak: number
    level: number
    dailyBaseXp: number
    dailyXp: number
    dailyDate: number
    lastSessionAt: number
    _all: number
  }


  export type UserStatsAvgAggregateInputType = {
    totalXp?: true
    weeklyXp?: true
    streak?: true
    level?: true
    dailyBaseXp?: true
    dailyXp?: true
  }

  export type UserStatsSumAggregateInputType = {
    totalXp?: true
    weeklyXp?: true
    streak?: true
    level?: true
    dailyBaseXp?: true
    dailyXp?: true
  }

  export type UserStatsMinAggregateInputType = {
    id?: true
    userId?: true
    totalXp?: true
    weeklyXp?: true
    streak?: true
    level?: true
    dailyBaseXp?: true
    dailyXp?: true
    dailyDate?: true
    lastSessionAt?: true
  }

  export type UserStatsMaxAggregateInputType = {
    id?: true
    userId?: true
    totalXp?: true
    weeklyXp?: true
    streak?: true
    level?: true
    dailyBaseXp?: true
    dailyXp?: true
    dailyDate?: true
    lastSessionAt?: true
  }

  export type UserStatsCountAggregateInputType = {
    id?: true
    userId?: true
    totalXp?: true
    weeklyXp?: true
    streak?: true
    level?: true
    dailyBaseXp?: true
    dailyXp?: true
    dailyDate?: true
    lastSessionAt?: true
    _all?: true
  }

  export type UserStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserStats to aggregate.
     */
    where?: UserStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStats to fetch.
     */
    orderBy?: UserStatsOrderByWithRelationInput | UserStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserStats
    **/
    _count?: true | UserStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserStatsMaxAggregateInputType
  }

  export type GetUserStatsAggregateType<T extends UserStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserStats[P]>
      : GetScalarType<T[P], AggregateUserStats[P]>
  }




  export type UserStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserStatsWhereInput
    orderBy?: UserStatsOrderByWithAggregationInput | UserStatsOrderByWithAggregationInput[]
    by: UserStatsScalarFieldEnum[] | UserStatsScalarFieldEnum
    having?: UserStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserStatsCountAggregateInputType | true
    _avg?: UserStatsAvgAggregateInputType
    _sum?: UserStatsSumAggregateInputType
    _min?: UserStatsMinAggregateInputType
    _max?: UserStatsMaxAggregateInputType
  }

  export type UserStatsGroupByOutputType = {
    id: string
    userId: string
    totalXp: number
    weeklyXp: number
    streak: number
    level: number
    dailyBaseXp: number
    dailyXp: number
    dailyDate: Date | null
    lastSessionAt: Date | null
    _count: UserStatsCountAggregateOutputType | null
    _avg: UserStatsAvgAggregateOutputType | null
    _sum: UserStatsSumAggregateOutputType | null
    _min: UserStatsMinAggregateOutputType | null
    _max: UserStatsMaxAggregateOutputType | null
  }

  type GetUserStatsGroupByPayload<T extends UserStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserStatsGroupByOutputType[P]>
            : GetScalarType<T[P], UserStatsGroupByOutputType[P]>
        }
      >
    >


  export type UserStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalXp?: boolean
    weeklyXp?: boolean
    streak?: boolean
    level?: boolean
    dailyBaseXp?: boolean
    dailyXp?: boolean
    dailyDate?: boolean
    lastSessionAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userStats"]>

  export type UserStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalXp?: boolean
    weeklyXp?: boolean
    streak?: boolean
    level?: boolean
    dailyBaseXp?: boolean
    dailyXp?: boolean
    dailyDate?: boolean
    lastSessionAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userStats"]>

  export type UserStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalXp?: boolean
    weeklyXp?: boolean
    streak?: boolean
    level?: boolean
    dailyBaseXp?: boolean
    dailyXp?: boolean
    dailyDate?: boolean
    lastSessionAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userStats"]>

  export type UserStatsSelectScalar = {
    id?: boolean
    userId?: boolean
    totalXp?: boolean
    weeklyXp?: boolean
    streak?: boolean
    level?: boolean
    dailyBaseXp?: boolean
    dailyXp?: boolean
    dailyDate?: boolean
    lastSessionAt?: boolean
  }

  export type UserStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "totalXp" | "weeklyXp" | "streak" | "level" | "dailyBaseXp" | "dailyXp" | "dailyDate" | "lastSessionAt", ExtArgs["result"]["userStats"]>
  export type UserStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserStatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserStats"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      totalXp: number
      weeklyXp: number
      streak: number
      level: number
      dailyBaseXp: number
      dailyXp: number
      dailyDate: Date | null
      lastSessionAt: Date | null
    }, ExtArgs["result"]["userStats"]>
    composites: {}
  }

  type UserStatsGetPayload<S extends boolean | null | undefined | UserStatsDefaultArgs> = $Result.GetResult<Prisma.$UserStatsPayload, S>

  type UserStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserStatsCountAggregateInputType | true
    }

  export interface UserStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserStats'], meta: { name: 'UserStats' } }
    /**
     * Find zero or one UserStats that matches the filter.
     * @param {UserStatsFindUniqueArgs} args - Arguments to find a UserStats
     * @example
     * // Get one UserStats
     * const userStats = await prisma.userStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserStatsFindUniqueArgs>(args: SelectSubset<T, UserStatsFindUniqueArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserStatsFindUniqueOrThrowArgs} args - Arguments to find a UserStats
     * @example
     * // Get one UserStats
     * const userStats = await prisma.userStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsFindFirstArgs} args - Arguments to find a UserStats
     * @example
     * // Get one UserStats
     * const userStats = await prisma.userStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserStatsFindFirstArgs>(args?: SelectSubset<T, UserStatsFindFirstArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsFindFirstOrThrowArgs} args - Arguments to find a UserStats
     * @example
     * // Get one UserStats
     * const userStats = await prisma.userStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserStats
     * const userStats = await prisma.userStats.findMany()
     * 
     * // Get first 10 UserStats
     * const userStats = await prisma.userStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userStatsWithIdOnly = await prisma.userStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserStatsFindManyArgs>(args?: SelectSubset<T, UserStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserStats.
     * @param {UserStatsCreateArgs} args - Arguments to create a UserStats.
     * @example
     * // Create one UserStats
     * const UserStats = await prisma.userStats.create({
     *   data: {
     *     // ... data to create a UserStats
     *   }
     * })
     * 
     */
    create<T extends UserStatsCreateArgs>(args: SelectSubset<T, UserStatsCreateArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserStats.
     * @param {UserStatsCreateManyArgs} args - Arguments to create many UserStats.
     * @example
     * // Create many UserStats
     * const userStats = await prisma.userStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserStatsCreateManyArgs>(args?: SelectSubset<T, UserStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserStats and returns the data saved in the database.
     * @param {UserStatsCreateManyAndReturnArgs} args - Arguments to create many UserStats.
     * @example
     * // Create many UserStats
     * const userStats = await prisma.userStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserStats and only return the `id`
     * const userStatsWithIdOnly = await prisma.userStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserStats.
     * @param {UserStatsDeleteArgs} args - Arguments to delete one UserStats.
     * @example
     * // Delete one UserStats
     * const UserStats = await prisma.userStats.delete({
     *   where: {
     *     // ... filter to delete one UserStats
     *   }
     * })
     * 
     */
    delete<T extends UserStatsDeleteArgs>(args: SelectSubset<T, UserStatsDeleteArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserStats.
     * @param {UserStatsUpdateArgs} args - Arguments to update one UserStats.
     * @example
     * // Update one UserStats
     * const userStats = await prisma.userStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserStatsUpdateArgs>(args: SelectSubset<T, UserStatsUpdateArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserStats.
     * @param {UserStatsDeleteManyArgs} args - Arguments to filter UserStats to delete.
     * @example
     * // Delete a few UserStats
     * const { count } = await prisma.userStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserStatsDeleteManyArgs>(args?: SelectSubset<T, UserStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserStats
     * const userStats = await prisma.userStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserStatsUpdateManyArgs>(args: SelectSubset<T, UserStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserStats and returns the data updated in the database.
     * @param {UserStatsUpdateManyAndReturnArgs} args - Arguments to update many UserStats.
     * @example
     * // Update many UserStats
     * const userStats = await prisma.userStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserStats and only return the `id`
     * const userStatsWithIdOnly = await prisma.userStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserStats.
     * @param {UserStatsUpsertArgs} args - Arguments to update or create a UserStats.
     * @example
     * // Update or create a UserStats
     * const userStats = await prisma.userStats.upsert({
     *   create: {
     *     // ... data to create a UserStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserStats we want to update
     *   }
     * })
     */
    upsert<T extends UserStatsUpsertArgs>(args: SelectSubset<T, UserStatsUpsertArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsCountArgs} args - Arguments to filter UserStats to count.
     * @example
     * // Count the number of UserStats
     * const count = await prisma.userStats.count({
     *   where: {
     *     // ... the filter for the UserStats we want to count
     *   }
     * })
    **/
    count<T extends UserStatsCountArgs>(
      args?: Subset<T, UserStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserStatsAggregateArgs>(args: Subset<T, UserStatsAggregateArgs>): Prisma.PrismaPromise<GetUserStatsAggregateType<T>>

    /**
     * Group by UserStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserStatsGroupByArgs['orderBy'] }
        : { orderBy?: UserStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserStats model
   */
  readonly fields: UserStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserStats model
   */
  interface UserStatsFieldRefs {
    readonly id: FieldRef<"UserStats", 'String'>
    readonly userId: FieldRef<"UserStats", 'String'>
    readonly totalXp: FieldRef<"UserStats", 'Int'>
    readonly weeklyXp: FieldRef<"UserStats", 'Int'>
    readonly streak: FieldRef<"UserStats", 'Int'>
    readonly level: FieldRef<"UserStats", 'Int'>
    readonly dailyBaseXp: FieldRef<"UserStats", 'Int'>
    readonly dailyXp: FieldRef<"UserStats", 'Int'>
    readonly dailyDate: FieldRef<"UserStats", 'DateTime'>
    readonly lastSessionAt: FieldRef<"UserStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserStats findUnique
   */
  export type UserStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where: UserStatsWhereUniqueInput
  }

  /**
   * UserStats findUniqueOrThrow
   */
  export type UserStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where: UserStatsWhereUniqueInput
  }

  /**
   * UserStats findFirst
   */
  export type UserStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where?: UserStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStats to fetch.
     */
    orderBy?: UserStatsOrderByWithRelationInput | UserStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserStats.
     */
    cursor?: UserStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserStats.
     */
    distinct?: UserStatsScalarFieldEnum | UserStatsScalarFieldEnum[]
  }

  /**
   * UserStats findFirstOrThrow
   */
  export type UserStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where?: UserStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStats to fetch.
     */
    orderBy?: UserStatsOrderByWithRelationInput | UserStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserStats.
     */
    cursor?: UserStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserStats.
     */
    distinct?: UserStatsScalarFieldEnum | UserStatsScalarFieldEnum[]
  }

  /**
   * UserStats findMany
   */
  export type UserStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where?: UserStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStats to fetch.
     */
    orderBy?: UserStatsOrderByWithRelationInput | UserStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserStats.
     */
    cursor?: UserStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStats.
     */
    skip?: number
    distinct?: UserStatsScalarFieldEnum | UserStatsScalarFieldEnum[]
  }

  /**
   * UserStats create
   */
  export type UserStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserStats.
     */
    data: XOR<UserStatsCreateInput, UserStatsUncheckedCreateInput>
  }

  /**
   * UserStats createMany
   */
  export type UserStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserStats.
     */
    data: UserStatsCreateManyInput | UserStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserStats createManyAndReturn
   */
  export type UserStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * The data used to create many UserStats.
     */
    data: UserStatsCreateManyInput | UserStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserStats update
   */
  export type UserStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserStats.
     */
    data: XOR<UserStatsUpdateInput, UserStatsUncheckedUpdateInput>
    /**
     * Choose, which UserStats to update.
     */
    where: UserStatsWhereUniqueInput
  }

  /**
   * UserStats updateMany
   */
  export type UserStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserStats.
     */
    data: XOR<UserStatsUpdateManyMutationInput, UserStatsUncheckedUpdateManyInput>
    /**
     * Filter which UserStats to update
     */
    where?: UserStatsWhereInput
    /**
     * Limit how many UserStats to update.
     */
    limit?: number
  }

  /**
   * UserStats updateManyAndReturn
   */
  export type UserStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * The data used to update UserStats.
     */
    data: XOR<UserStatsUpdateManyMutationInput, UserStatsUncheckedUpdateManyInput>
    /**
     * Filter which UserStats to update
     */
    where?: UserStatsWhereInput
    /**
     * Limit how many UserStats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserStats upsert
   */
  export type UserStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserStats to update in case it exists.
     */
    where: UserStatsWhereUniqueInput
    /**
     * In case the UserStats found by the `where` argument doesn't exist, create a new UserStats with this data.
     */
    create: XOR<UserStatsCreateInput, UserStatsUncheckedCreateInput>
    /**
     * In case the UserStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserStatsUpdateInput, UserStatsUncheckedUpdateInput>
  }

  /**
   * UserStats delete
   */
  export type UserStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * Filter which UserStats to delete.
     */
    where: UserStatsWhereUniqueInput
  }

  /**
   * UserStats deleteMany
   */
  export type UserStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserStats to delete
     */
    where?: UserStatsWhereInput
    /**
     * Limit how many UserStats to delete.
     */
    limit?: number
  }

  /**
   * UserStats without action
   */
  export type UserStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
  }


  /**
   * Model IntegrationCanvas
   */

  export type AggregateIntegrationCanvas = {
    _count: IntegrationCanvasCountAggregateOutputType | null
    _min: IntegrationCanvasMinAggregateOutputType | null
    _max: IntegrationCanvasMaxAggregateOutputType | null
  }

  export type IntegrationCanvasMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tokenEncrypted: string | null
    canvasBaseUrl: string | null
    canvasUserId: string | null
    lastImportedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntegrationCanvasMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tokenEncrypted: string | null
    canvasBaseUrl: string | null
    canvasUserId: string | null
    lastImportedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntegrationCanvasCountAggregateOutputType = {
    id: number
    userId: number
    tokenEncrypted: number
    canvasBaseUrl: number
    canvasUserId: number
    lastImportedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntegrationCanvasMinAggregateInputType = {
    id?: true
    userId?: true
    tokenEncrypted?: true
    canvasBaseUrl?: true
    canvasUserId?: true
    lastImportedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntegrationCanvasMaxAggregateInputType = {
    id?: true
    userId?: true
    tokenEncrypted?: true
    canvasBaseUrl?: true
    canvasUserId?: true
    lastImportedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntegrationCanvasCountAggregateInputType = {
    id?: true
    userId?: true
    tokenEncrypted?: true
    canvasBaseUrl?: true
    canvasUserId?: true
    lastImportedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntegrationCanvasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntegrationCanvas to aggregate.
     */
    where?: IntegrationCanvasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegrationCanvas to fetch.
     */
    orderBy?: IntegrationCanvasOrderByWithRelationInput | IntegrationCanvasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntegrationCanvasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegrationCanvas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegrationCanvas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntegrationCanvas
    **/
    _count?: true | IntegrationCanvasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntegrationCanvasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntegrationCanvasMaxAggregateInputType
  }

  export type GetIntegrationCanvasAggregateType<T extends IntegrationCanvasAggregateArgs> = {
        [P in keyof T & keyof AggregateIntegrationCanvas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntegrationCanvas[P]>
      : GetScalarType<T[P], AggregateIntegrationCanvas[P]>
  }




  export type IntegrationCanvasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationCanvasWhereInput
    orderBy?: IntegrationCanvasOrderByWithAggregationInput | IntegrationCanvasOrderByWithAggregationInput[]
    by: IntegrationCanvasScalarFieldEnum[] | IntegrationCanvasScalarFieldEnum
    having?: IntegrationCanvasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntegrationCanvasCountAggregateInputType | true
    _min?: IntegrationCanvasMinAggregateInputType
    _max?: IntegrationCanvasMaxAggregateInputType
  }

  export type IntegrationCanvasGroupByOutputType = {
    id: string
    userId: string
    tokenEncrypted: string | null
    canvasBaseUrl: string
    canvasUserId: string | null
    lastImportedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: IntegrationCanvasCountAggregateOutputType | null
    _min: IntegrationCanvasMinAggregateOutputType | null
    _max: IntegrationCanvasMaxAggregateOutputType | null
  }

  type GetIntegrationCanvasGroupByPayload<T extends IntegrationCanvasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntegrationCanvasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntegrationCanvasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntegrationCanvasGroupByOutputType[P]>
            : GetScalarType<T[P], IntegrationCanvasGroupByOutputType[P]>
        }
      >
    >


  export type IntegrationCanvasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenEncrypted?: boolean
    canvasBaseUrl?: boolean
    canvasUserId?: boolean
    lastImportedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integrationCanvas"]>

  export type IntegrationCanvasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenEncrypted?: boolean
    canvasBaseUrl?: boolean
    canvasUserId?: boolean
    lastImportedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integrationCanvas"]>

  export type IntegrationCanvasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenEncrypted?: boolean
    canvasBaseUrl?: boolean
    canvasUserId?: boolean
    lastImportedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integrationCanvas"]>

  export type IntegrationCanvasSelectScalar = {
    id?: boolean
    userId?: boolean
    tokenEncrypted?: boolean
    canvasBaseUrl?: boolean
    canvasUserId?: boolean
    lastImportedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntegrationCanvasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "tokenEncrypted" | "canvasBaseUrl" | "canvasUserId" | "lastImportedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["integrationCanvas"]>
  export type IntegrationCanvasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type IntegrationCanvasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type IntegrationCanvasIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $IntegrationCanvasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IntegrationCanvas"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tokenEncrypted: string | null
      canvasBaseUrl: string
      canvasUserId: string | null
      lastImportedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["integrationCanvas"]>
    composites: {}
  }

  type IntegrationCanvasGetPayload<S extends boolean | null | undefined | IntegrationCanvasDefaultArgs> = $Result.GetResult<Prisma.$IntegrationCanvasPayload, S>

  type IntegrationCanvasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IntegrationCanvasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IntegrationCanvasCountAggregateInputType | true
    }

  export interface IntegrationCanvasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IntegrationCanvas'], meta: { name: 'IntegrationCanvas' } }
    /**
     * Find zero or one IntegrationCanvas that matches the filter.
     * @param {IntegrationCanvasFindUniqueArgs} args - Arguments to find a IntegrationCanvas
     * @example
     * // Get one IntegrationCanvas
     * const integrationCanvas = await prisma.integrationCanvas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntegrationCanvasFindUniqueArgs>(args: SelectSubset<T, IntegrationCanvasFindUniqueArgs<ExtArgs>>): Prisma__IntegrationCanvasClient<$Result.GetResult<Prisma.$IntegrationCanvasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IntegrationCanvas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IntegrationCanvasFindUniqueOrThrowArgs} args - Arguments to find a IntegrationCanvas
     * @example
     * // Get one IntegrationCanvas
     * const integrationCanvas = await prisma.integrationCanvas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntegrationCanvasFindUniqueOrThrowArgs>(args: SelectSubset<T, IntegrationCanvasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntegrationCanvasClient<$Result.GetResult<Prisma.$IntegrationCanvasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IntegrationCanvas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationCanvasFindFirstArgs} args - Arguments to find a IntegrationCanvas
     * @example
     * // Get one IntegrationCanvas
     * const integrationCanvas = await prisma.integrationCanvas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntegrationCanvasFindFirstArgs>(args?: SelectSubset<T, IntegrationCanvasFindFirstArgs<ExtArgs>>): Prisma__IntegrationCanvasClient<$Result.GetResult<Prisma.$IntegrationCanvasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IntegrationCanvas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationCanvasFindFirstOrThrowArgs} args - Arguments to find a IntegrationCanvas
     * @example
     * // Get one IntegrationCanvas
     * const integrationCanvas = await prisma.integrationCanvas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntegrationCanvasFindFirstOrThrowArgs>(args?: SelectSubset<T, IntegrationCanvasFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntegrationCanvasClient<$Result.GetResult<Prisma.$IntegrationCanvasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IntegrationCanvas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationCanvasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntegrationCanvas
     * const integrationCanvas = await prisma.integrationCanvas.findMany()
     * 
     * // Get first 10 IntegrationCanvas
     * const integrationCanvas = await prisma.integrationCanvas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const integrationCanvasWithIdOnly = await prisma.integrationCanvas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntegrationCanvasFindManyArgs>(args?: SelectSubset<T, IntegrationCanvasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationCanvasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IntegrationCanvas.
     * @param {IntegrationCanvasCreateArgs} args - Arguments to create a IntegrationCanvas.
     * @example
     * // Create one IntegrationCanvas
     * const IntegrationCanvas = await prisma.integrationCanvas.create({
     *   data: {
     *     // ... data to create a IntegrationCanvas
     *   }
     * })
     * 
     */
    create<T extends IntegrationCanvasCreateArgs>(args: SelectSubset<T, IntegrationCanvasCreateArgs<ExtArgs>>): Prisma__IntegrationCanvasClient<$Result.GetResult<Prisma.$IntegrationCanvasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IntegrationCanvas.
     * @param {IntegrationCanvasCreateManyArgs} args - Arguments to create many IntegrationCanvas.
     * @example
     * // Create many IntegrationCanvas
     * const integrationCanvas = await prisma.integrationCanvas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntegrationCanvasCreateManyArgs>(args?: SelectSubset<T, IntegrationCanvasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IntegrationCanvas and returns the data saved in the database.
     * @param {IntegrationCanvasCreateManyAndReturnArgs} args - Arguments to create many IntegrationCanvas.
     * @example
     * // Create many IntegrationCanvas
     * const integrationCanvas = await prisma.integrationCanvas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IntegrationCanvas and only return the `id`
     * const integrationCanvasWithIdOnly = await prisma.integrationCanvas.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntegrationCanvasCreateManyAndReturnArgs>(args?: SelectSubset<T, IntegrationCanvasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationCanvasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IntegrationCanvas.
     * @param {IntegrationCanvasDeleteArgs} args - Arguments to delete one IntegrationCanvas.
     * @example
     * // Delete one IntegrationCanvas
     * const IntegrationCanvas = await prisma.integrationCanvas.delete({
     *   where: {
     *     // ... filter to delete one IntegrationCanvas
     *   }
     * })
     * 
     */
    delete<T extends IntegrationCanvasDeleteArgs>(args: SelectSubset<T, IntegrationCanvasDeleteArgs<ExtArgs>>): Prisma__IntegrationCanvasClient<$Result.GetResult<Prisma.$IntegrationCanvasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IntegrationCanvas.
     * @param {IntegrationCanvasUpdateArgs} args - Arguments to update one IntegrationCanvas.
     * @example
     * // Update one IntegrationCanvas
     * const integrationCanvas = await prisma.integrationCanvas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntegrationCanvasUpdateArgs>(args: SelectSubset<T, IntegrationCanvasUpdateArgs<ExtArgs>>): Prisma__IntegrationCanvasClient<$Result.GetResult<Prisma.$IntegrationCanvasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IntegrationCanvas.
     * @param {IntegrationCanvasDeleteManyArgs} args - Arguments to filter IntegrationCanvas to delete.
     * @example
     * // Delete a few IntegrationCanvas
     * const { count } = await prisma.integrationCanvas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntegrationCanvasDeleteManyArgs>(args?: SelectSubset<T, IntegrationCanvasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntegrationCanvas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationCanvasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntegrationCanvas
     * const integrationCanvas = await prisma.integrationCanvas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntegrationCanvasUpdateManyArgs>(args: SelectSubset<T, IntegrationCanvasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntegrationCanvas and returns the data updated in the database.
     * @param {IntegrationCanvasUpdateManyAndReturnArgs} args - Arguments to update many IntegrationCanvas.
     * @example
     * // Update many IntegrationCanvas
     * const integrationCanvas = await prisma.integrationCanvas.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IntegrationCanvas and only return the `id`
     * const integrationCanvasWithIdOnly = await prisma.integrationCanvas.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IntegrationCanvasUpdateManyAndReturnArgs>(args: SelectSubset<T, IntegrationCanvasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationCanvasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IntegrationCanvas.
     * @param {IntegrationCanvasUpsertArgs} args - Arguments to update or create a IntegrationCanvas.
     * @example
     * // Update or create a IntegrationCanvas
     * const integrationCanvas = await prisma.integrationCanvas.upsert({
     *   create: {
     *     // ... data to create a IntegrationCanvas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntegrationCanvas we want to update
     *   }
     * })
     */
    upsert<T extends IntegrationCanvasUpsertArgs>(args: SelectSubset<T, IntegrationCanvasUpsertArgs<ExtArgs>>): Prisma__IntegrationCanvasClient<$Result.GetResult<Prisma.$IntegrationCanvasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IntegrationCanvas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationCanvasCountArgs} args - Arguments to filter IntegrationCanvas to count.
     * @example
     * // Count the number of IntegrationCanvas
     * const count = await prisma.integrationCanvas.count({
     *   where: {
     *     // ... the filter for the IntegrationCanvas we want to count
     *   }
     * })
    **/
    count<T extends IntegrationCanvasCountArgs>(
      args?: Subset<T, IntegrationCanvasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntegrationCanvasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntegrationCanvas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationCanvasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntegrationCanvasAggregateArgs>(args: Subset<T, IntegrationCanvasAggregateArgs>): Prisma.PrismaPromise<GetIntegrationCanvasAggregateType<T>>

    /**
     * Group by IntegrationCanvas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationCanvasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntegrationCanvasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntegrationCanvasGroupByArgs['orderBy'] }
        : { orderBy?: IntegrationCanvasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntegrationCanvasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntegrationCanvasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IntegrationCanvas model
   */
  readonly fields: IntegrationCanvasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntegrationCanvas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntegrationCanvasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IntegrationCanvas model
   */
  interface IntegrationCanvasFieldRefs {
    readonly id: FieldRef<"IntegrationCanvas", 'String'>
    readonly userId: FieldRef<"IntegrationCanvas", 'String'>
    readonly tokenEncrypted: FieldRef<"IntegrationCanvas", 'String'>
    readonly canvasBaseUrl: FieldRef<"IntegrationCanvas", 'String'>
    readonly canvasUserId: FieldRef<"IntegrationCanvas", 'String'>
    readonly lastImportedAt: FieldRef<"IntegrationCanvas", 'DateTime'>
    readonly createdAt: FieldRef<"IntegrationCanvas", 'DateTime'>
    readonly updatedAt: FieldRef<"IntegrationCanvas", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IntegrationCanvas findUnique
   */
  export type IntegrationCanvasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationCanvas
     */
    select?: IntegrationCanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationCanvas
     */
    omit?: IntegrationCanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationCanvasInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationCanvas to fetch.
     */
    where: IntegrationCanvasWhereUniqueInput
  }

  /**
   * IntegrationCanvas findUniqueOrThrow
   */
  export type IntegrationCanvasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationCanvas
     */
    select?: IntegrationCanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationCanvas
     */
    omit?: IntegrationCanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationCanvasInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationCanvas to fetch.
     */
    where: IntegrationCanvasWhereUniqueInput
  }

  /**
   * IntegrationCanvas findFirst
   */
  export type IntegrationCanvasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationCanvas
     */
    select?: IntegrationCanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationCanvas
     */
    omit?: IntegrationCanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationCanvasInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationCanvas to fetch.
     */
    where?: IntegrationCanvasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegrationCanvas to fetch.
     */
    orderBy?: IntegrationCanvasOrderByWithRelationInput | IntegrationCanvasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntegrationCanvas.
     */
    cursor?: IntegrationCanvasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegrationCanvas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegrationCanvas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntegrationCanvas.
     */
    distinct?: IntegrationCanvasScalarFieldEnum | IntegrationCanvasScalarFieldEnum[]
  }

  /**
   * IntegrationCanvas findFirstOrThrow
   */
  export type IntegrationCanvasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationCanvas
     */
    select?: IntegrationCanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationCanvas
     */
    omit?: IntegrationCanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationCanvasInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationCanvas to fetch.
     */
    where?: IntegrationCanvasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegrationCanvas to fetch.
     */
    orderBy?: IntegrationCanvasOrderByWithRelationInput | IntegrationCanvasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntegrationCanvas.
     */
    cursor?: IntegrationCanvasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegrationCanvas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegrationCanvas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntegrationCanvas.
     */
    distinct?: IntegrationCanvasScalarFieldEnum | IntegrationCanvasScalarFieldEnum[]
  }

  /**
   * IntegrationCanvas findMany
   */
  export type IntegrationCanvasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationCanvas
     */
    select?: IntegrationCanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationCanvas
     */
    omit?: IntegrationCanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationCanvasInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationCanvas to fetch.
     */
    where?: IntegrationCanvasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegrationCanvas to fetch.
     */
    orderBy?: IntegrationCanvasOrderByWithRelationInput | IntegrationCanvasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntegrationCanvas.
     */
    cursor?: IntegrationCanvasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegrationCanvas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegrationCanvas.
     */
    skip?: number
    distinct?: IntegrationCanvasScalarFieldEnum | IntegrationCanvasScalarFieldEnum[]
  }

  /**
   * IntegrationCanvas create
   */
  export type IntegrationCanvasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationCanvas
     */
    select?: IntegrationCanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationCanvas
     */
    omit?: IntegrationCanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationCanvasInclude<ExtArgs> | null
    /**
     * The data needed to create a IntegrationCanvas.
     */
    data: XOR<IntegrationCanvasCreateInput, IntegrationCanvasUncheckedCreateInput>
  }

  /**
   * IntegrationCanvas createMany
   */
  export type IntegrationCanvasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IntegrationCanvas.
     */
    data: IntegrationCanvasCreateManyInput | IntegrationCanvasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IntegrationCanvas createManyAndReturn
   */
  export type IntegrationCanvasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationCanvas
     */
    select?: IntegrationCanvasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationCanvas
     */
    omit?: IntegrationCanvasOmit<ExtArgs> | null
    /**
     * The data used to create many IntegrationCanvas.
     */
    data: IntegrationCanvasCreateManyInput | IntegrationCanvasCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationCanvasIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IntegrationCanvas update
   */
  export type IntegrationCanvasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationCanvas
     */
    select?: IntegrationCanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationCanvas
     */
    omit?: IntegrationCanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationCanvasInclude<ExtArgs> | null
    /**
     * The data needed to update a IntegrationCanvas.
     */
    data: XOR<IntegrationCanvasUpdateInput, IntegrationCanvasUncheckedUpdateInput>
    /**
     * Choose, which IntegrationCanvas to update.
     */
    where: IntegrationCanvasWhereUniqueInput
  }

  /**
   * IntegrationCanvas updateMany
   */
  export type IntegrationCanvasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IntegrationCanvas.
     */
    data: XOR<IntegrationCanvasUpdateManyMutationInput, IntegrationCanvasUncheckedUpdateManyInput>
    /**
     * Filter which IntegrationCanvas to update
     */
    where?: IntegrationCanvasWhereInput
    /**
     * Limit how many IntegrationCanvas to update.
     */
    limit?: number
  }

  /**
   * IntegrationCanvas updateManyAndReturn
   */
  export type IntegrationCanvasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationCanvas
     */
    select?: IntegrationCanvasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationCanvas
     */
    omit?: IntegrationCanvasOmit<ExtArgs> | null
    /**
     * The data used to update IntegrationCanvas.
     */
    data: XOR<IntegrationCanvasUpdateManyMutationInput, IntegrationCanvasUncheckedUpdateManyInput>
    /**
     * Filter which IntegrationCanvas to update
     */
    where?: IntegrationCanvasWhereInput
    /**
     * Limit how many IntegrationCanvas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationCanvasIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IntegrationCanvas upsert
   */
  export type IntegrationCanvasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationCanvas
     */
    select?: IntegrationCanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationCanvas
     */
    omit?: IntegrationCanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationCanvasInclude<ExtArgs> | null
    /**
     * The filter to search for the IntegrationCanvas to update in case it exists.
     */
    where: IntegrationCanvasWhereUniqueInput
    /**
     * In case the IntegrationCanvas found by the `where` argument doesn't exist, create a new IntegrationCanvas with this data.
     */
    create: XOR<IntegrationCanvasCreateInput, IntegrationCanvasUncheckedCreateInput>
    /**
     * In case the IntegrationCanvas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntegrationCanvasUpdateInput, IntegrationCanvasUncheckedUpdateInput>
  }

  /**
   * IntegrationCanvas delete
   */
  export type IntegrationCanvasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationCanvas
     */
    select?: IntegrationCanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationCanvas
     */
    omit?: IntegrationCanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationCanvasInclude<ExtArgs> | null
    /**
     * Filter which IntegrationCanvas to delete.
     */
    where: IntegrationCanvasWhereUniqueInput
  }

  /**
   * IntegrationCanvas deleteMany
   */
  export type IntegrationCanvasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntegrationCanvas to delete
     */
    where?: IntegrationCanvasWhereInput
    /**
     * Limit how many IntegrationCanvas to delete.
     */
    limit?: number
  }

  /**
   * IntegrationCanvas without action
   */
  export type IntegrationCanvasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationCanvas
     */
    select?: IntegrationCanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationCanvas
     */
    omit?: IntegrationCanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationCanvasInclude<ExtArgs> | null
  }


  /**
   * Model FixedEvent
   */

  export type AggregateFixedEvent = {
    _count: FixedEventCountAggregateOutputType | null
    _min: FixedEventMinAggregateOutputType | null
    _max: FixedEventMaxAggregateOutputType | null
  }

  export type FixedEventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    type: string | null
    start: Date | null
    end: Date | null
    notes: string | null
    source: string | null
    externalId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FixedEventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    type: string | null
    start: Date | null
    end: Date | null
    notes: string | null
    source: string | null
    externalId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FixedEventCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    type: number
    start: number
    end: number
    notes: number
    source: number
    externalId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FixedEventMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    type?: true
    start?: true
    end?: true
    notes?: true
    source?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FixedEventMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    type?: true
    start?: true
    end?: true
    notes?: true
    source?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FixedEventCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    type?: true
    start?: true
    end?: true
    notes?: true
    source?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FixedEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FixedEvent to aggregate.
     */
    where?: FixedEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FixedEvents to fetch.
     */
    orderBy?: FixedEventOrderByWithRelationInput | FixedEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FixedEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FixedEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FixedEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FixedEvents
    **/
    _count?: true | FixedEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FixedEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FixedEventMaxAggregateInputType
  }

  export type GetFixedEventAggregateType<T extends FixedEventAggregateArgs> = {
        [P in keyof T & keyof AggregateFixedEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFixedEvent[P]>
      : GetScalarType<T[P], AggregateFixedEvent[P]>
  }




  export type FixedEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FixedEventWhereInput
    orderBy?: FixedEventOrderByWithAggregationInput | FixedEventOrderByWithAggregationInput[]
    by: FixedEventScalarFieldEnum[] | FixedEventScalarFieldEnum
    having?: FixedEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FixedEventCountAggregateInputType | true
    _min?: FixedEventMinAggregateInputType
    _max?: FixedEventMaxAggregateInputType
  }

  export type FixedEventGroupByOutputType = {
    id: string
    userId: string
    title: string
    type: string
    start: Date
    end: Date
    notes: string | null
    source: string
    externalId: string | null
    createdAt: Date
    updatedAt: Date
    _count: FixedEventCountAggregateOutputType | null
    _min: FixedEventMinAggregateOutputType | null
    _max: FixedEventMaxAggregateOutputType | null
  }

  type GetFixedEventGroupByPayload<T extends FixedEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FixedEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FixedEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FixedEventGroupByOutputType[P]>
            : GetScalarType<T[P], FixedEventGroupByOutputType[P]>
        }
      >
    >


  export type FixedEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    type?: boolean
    start?: boolean
    end?: boolean
    notes?: boolean
    source?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fixedEvent"]>

  export type FixedEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    type?: boolean
    start?: boolean
    end?: boolean
    notes?: boolean
    source?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fixedEvent"]>

  export type FixedEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    type?: boolean
    start?: boolean
    end?: boolean
    notes?: boolean
    source?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fixedEvent"]>

  export type FixedEventSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    type?: boolean
    start?: boolean
    end?: boolean
    notes?: boolean
    source?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FixedEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "type" | "start" | "end" | "notes" | "source" | "externalId" | "createdAt" | "updatedAt", ExtArgs["result"]["fixedEvent"]>
  export type FixedEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FixedEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FixedEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FixedEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FixedEvent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      type: string
      start: Date
      end: Date
      notes: string | null
      source: string
      externalId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fixedEvent"]>
    composites: {}
  }

  type FixedEventGetPayload<S extends boolean | null | undefined | FixedEventDefaultArgs> = $Result.GetResult<Prisma.$FixedEventPayload, S>

  type FixedEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FixedEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FixedEventCountAggregateInputType | true
    }

  export interface FixedEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FixedEvent'], meta: { name: 'FixedEvent' } }
    /**
     * Find zero or one FixedEvent that matches the filter.
     * @param {FixedEventFindUniqueArgs} args - Arguments to find a FixedEvent
     * @example
     * // Get one FixedEvent
     * const fixedEvent = await prisma.fixedEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FixedEventFindUniqueArgs>(args: SelectSubset<T, FixedEventFindUniqueArgs<ExtArgs>>): Prisma__FixedEventClient<$Result.GetResult<Prisma.$FixedEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FixedEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FixedEventFindUniqueOrThrowArgs} args - Arguments to find a FixedEvent
     * @example
     * // Get one FixedEvent
     * const fixedEvent = await prisma.fixedEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FixedEventFindUniqueOrThrowArgs>(args: SelectSubset<T, FixedEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FixedEventClient<$Result.GetResult<Prisma.$FixedEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FixedEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FixedEventFindFirstArgs} args - Arguments to find a FixedEvent
     * @example
     * // Get one FixedEvent
     * const fixedEvent = await prisma.fixedEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FixedEventFindFirstArgs>(args?: SelectSubset<T, FixedEventFindFirstArgs<ExtArgs>>): Prisma__FixedEventClient<$Result.GetResult<Prisma.$FixedEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FixedEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FixedEventFindFirstOrThrowArgs} args - Arguments to find a FixedEvent
     * @example
     * // Get one FixedEvent
     * const fixedEvent = await prisma.fixedEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FixedEventFindFirstOrThrowArgs>(args?: SelectSubset<T, FixedEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__FixedEventClient<$Result.GetResult<Prisma.$FixedEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FixedEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FixedEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FixedEvents
     * const fixedEvents = await prisma.fixedEvent.findMany()
     * 
     * // Get first 10 FixedEvents
     * const fixedEvents = await prisma.fixedEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fixedEventWithIdOnly = await prisma.fixedEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FixedEventFindManyArgs>(args?: SelectSubset<T, FixedEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FixedEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FixedEvent.
     * @param {FixedEventCreateArgs} args - Arguments to create a FixedEvent.
     * @example
     * // Create one FixedEvent
     * const FixedEvent = await prisma.fixedEvent.create({
     *   data: {
     *     // ... data to create a FixedEvent
     *   }
     * })
     * 
     */
    create<T extends FixedEventCreateArgs>(args: SelectSubset<T, FixedEventCreateArgs<ExtArgs>>): Prisma__FixedEventClient<$Result.GetResult<Prisma.$FixedEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FixedEvents.
     * @param {FixedEventCreateManyArgs} args - Arguments to create many FixedEvents.
     * @example
     * // Create many FixedEvents
     * const fixedEvent = await prisma.fixedEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FixedEventCreateManyArgs>(args?: SelectSubset<T, FixedEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FixedEvents and returns the data saved in the database.
     * @param {FixedEventCreateManyAndReturnArgs} args - Arguments to create many FixedEvents.
     * @example
     * // Create many FixedEvents
     * const fixedEvent = await prisma.fixedEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FixedEvents and only return the `id`
     * const fixedEventWithIdOnly = await prisma.fixedEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FixedEventCreateManyAndReturnArgs>(args?: SelectSubset<T, FixedEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FixedEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FixedEvent.
     * @param {FixedEventDeleteArgs} args - Arguments to delete one FixedEvent.
     * @example
     * // Delete one FixedEvent
     * const FixedEvent = await prisma.fixedEvent.delete({
     *   where: {
     *     // ... filter to delete one FixedEvent
     *   }
     * })
     * 
     */
    delete<T extends FixedEventDeleteArgs>(args: SelectSubset<T, FixedEventDeleteArgs<ExtArgs>>): Prisma__FixedEventClient<$Result.GetResult<Prisma.$FixedEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FixedEvent.
     * @param {FixedEventUpdateArgs} args - Arguments to update one FixedEvent.
     * @example
     * // Update one FixedEvent
     * const fixedEvent = await prisma.fixedEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FixedEventUpdateArgs>(args: SelectSubset<T, FixedEventUpdateArgs<ExtArgs>>): Prisma__FixedEventClient<$Result.GetResult<Prisma.$FixedEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FixedEvents.
     * @param {FixedEventDeleteManyArgs} args - Arguments to filter FixedEvents to delete.
     * @example
     * // Delete a few FixedEvents
     * const { count } = await prisma.fixedEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FixedEventDeleteManyArgs>(args?: SelectSubset<T, FixedEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FixedEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FixedEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FixedEvents
     * const fixedEvent = await prisma.fixedEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FixedEventUpdateManyArgs>(args: SelectSubset<T, FixedEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FixedEvents and returns the data updated in the database.
     * @param {FixedEventUpdateManyAndReturnArgs} args - Arguments to update many FixedEvents.
     * @example
     * // Update many FixedEvents
     * const fixedEvent = await prisma.fixedEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FixedEvents and only return the `id`
     * const fixedEventWithIdOnly = await prisma.fixedEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FixedEventUpdateManyAndReturnArgs>(args: SelectSubset<T, FixedEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FixedEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FixedEvent.
     * @param {FixedEventUpsertArgs} args - Arguments to update or create a FixedEvent.
     * @example
     * // Update or create a FixedEvent
     * const fixedEvent = await prisma.fixedEvent.upsert({
     *   create: {
     *     // ... data to create a FixedEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FixedEvent we want to update
     *   }
     * })
     */
    upsert<T extends FixedEventUpsertArgs>(args: SelectSubset<T, FixedEventUpsertArgs<ExtArgs>>): Prisma__FixedEventClient<$Result.GetResult<Prisma.$FixedEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FixedEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FixedEventCountArgs} args - Arguments to filter FixedEvents to count.
     * @example
     * // Count the number of FixedEvents
     * const count = await prisma.fixedEvent.count({
     *   where: {
     *     // ... the filter for the FixedEvents we want to count
     *   }
     * })
    **/
    count<T extends FixedEventCountArgs>(
      args?: Subset<T, FixedEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FixedEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FixedEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FixedEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FixedEventAggregateArgs>(args: Subset<T, FixedEventAggregateArgs>): Prisma.PrismaPromise<GetFixedEventAggregateType<T>>

    /**
     * Group by FixedEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FixedEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FixedEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FixedEventGroupByArgs['orderBy'] }
        : { orderBy?: FixedEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FixedEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFixedEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FixedEvent model
   */
  readonly fields: FixedEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FixedEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FixedEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FixedEvent model
   */
  interface FixedEventFieldRefs {
    readonly id: FieldRef<"FixedEvent", 'String'>
    readonly userId: FieldRef<"FixedEvent", 'String'>
    readonly title: FieldRef<"FixedEvent", 'String'>
    readonly type: FieldRef<"FixedEvent", 'String'>
    readonly start: FieldRef<"FixedEvent", 'DateTime'>
    readonly end: FieldRef<"FixedEvent", 'DateTime'>
    readonly notes: FieldRef<"FixedEvent", 'String'>
    readonly source: FieldRef<"FixedEvent", 'String'>
    readonly externalId: FieldRef<"FixedEvent", 'String'>
    readonly createdAt: FieldRef<"FixedEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"FixedEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FixedEvent findUnique
   */
  export type FixedEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixedEvent
     */
    select?: FixedEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FixedEvent
     */
    omit?: FixedEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixedEventInclude<ExtArgs> | null
    /**
     * Filter, which FixedEvent to fetch.
     */
    where: FixedEventWhereUniqueInput
  }

  /**
   * FixedEvent findUniqueOrThrow
   */
  export type FixedEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixedEvent
     */
    select?: FixedEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FixedEvent
     */
    omit?: FixedEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixedEventInclude<ExtArgs> | null
    /**
     * Filter, which FixedEvent to fetch.
     */
    where: FixedEventWhereUniqueInput
  }

  /**
   * FixedEvent findFirst
   */
  export type FixedEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixedEvent
     */
    select?: FixedEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FixedEvent
     */
    omit?: FixedEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixedEventInclude<ExtArgs> | null
    /**
     * Filter, which FixedEvent to fetch.
     */
    where?: FixedEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FixedEvents to fetch.
     */
    orderBy?: FixedEventOrderByWithRelationInput | FixedEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FixedEvents.
     */
    cursor?: FixedEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FixedEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FixedEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FixedEvents.
     */
    distinct?: FixedEventScalarFieldEnum | FixedEventScalarFieldEnum[]
  }

  /**
   * FixedEvent findFirstOrThrow
   */
  export type FixedEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixedEvent
     */
    select?: FixedEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FixedEvent
     */
    omit?: FixedEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixedEventInclude<ExtArgs> | null
    /**
     * Filter, which FixedEvent to fetch.
     */
    where?: FixedEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FixedEvents to fetch.
     */
    orderBy?: FixedEventOrderByWithRelationInput | FixedEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FixedEvents.
     */
    cursor?: FixedEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FixedEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FixedEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FixedEvents.
     */
    distinct?: FixedEventScalarFieldEnum | FixedEventScalarFieldEnum[]
  }

  /**
   * FixedEvent findMany
   */
  export type FixedEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixedEvent
     */
    select?: FixedEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FixedEvent
     */
    omit?: FixedEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixedEventInclude<ExtArgs> | null
    /**
     * Filter, which FixedEvents to fetch.
     */
    where?: FixedEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FixedEvents to fetch.
     */
    orderBy?: FixedEventOrderByWithRelationInput | FixedEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FixedEvents.
     */
    cursor?: FixedEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FixedEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FixedEvents.
     */
    skip?: number
    distinct?: FixedEventScalarFieldEnum | FixedEventScalarFieldEnum[]
  }

  /**
   * FixedEvent create
   */
  export type FixedEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixedEvent
     */
    select?: FixedEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FixedEvent
     */
    omit?: FixedEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixedEventInclude<ExtArgs> | null
    /**
     * The data needed to create a FixedEvent.
     */
    data: XOR<FixedEventCreateInput, FixedEventUncheckedCreateInput>
  }

  /**
   * FixedEvent createMany
   */
  export type FixedEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FixedEvents.
     */
    data: FixedEventCreateManyInput | FixedEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FixedEvent createManyAndReturn
   */
  export type FixedEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixedEvent
     */
    select?: FixedEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FixedEvent
     */
    omit?: FixedEventOmit<ExtArgs> | null
    /**
     * The data used to create many FixedEvents.
     */
    data: FixedEventCreateManyInput | FixedEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixedEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FixedEvent update
   */
  export type FixedEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixedEvent
     */
    select?: FixedEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FixedEvent
     */
    omit?: FixedEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixedEventInclude<ExtArgs> | null
    /**
     * The data needed to update a FixedEvent.
     */
    data: XOR<FixedEventUpdateInput, FixedEventUncheckedUpdateInput>
    /**
     * Choose, which FixedEvent to update.
     */
    where: FixedEventWhereUniqueInput
  }

  /**
   * FixedEvent updateMany
   */
  export type FixedEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FixedEvents.
     */
    data: XOR<FixedEventUpdateManyMutationInput, FixedEventUncheckedUpdateManyInput>
    /**
     * Filter which FixedEvents to update
     */
    where?: FixedEventWhereInput
    /**
     * Limit how many FixedEvents to update.
     */
    limit?: number
  }

  /**
   * FixedEvent updateManyAndReturn
   */
  export type FixedEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixedEvent
     */
    select?: FixedEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FixedEvent
     */
    omit?: FixedEventOmit<ExtArgs> | null
    /**
     * The data used to update FixedEvents.
     */
    data: XOR<FixedEventUpdateManyMutationInput, FixedEventUncheckedUpdateManyInput>
    /**
     * Filter which FixedEvents to update
     */
    where?: FixedEventWhereInput
    /**
     * Limit how many FixedEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixedEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FixedEvent upsert
   */
  export type FixedEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixedEvent
     */
    select?: FixedEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FixedEvent
     */
    omit?: FixedEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixedEventInclude<ExtArgs> | null
    /**
     * The filter to search for the FixedEvent to update in case it exists.
     */
    where: FixedEventWhereUniqueInput
    /**
     * In case the FixedEvent found by the `where` argument doesn't exist, create a new FixedEvent with this data.
     */
    create: XOR<FixedEventCreateInput, FixedEventUncheckedCreateInput>
    /**
     * In case the FixedEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FixedEventUpdateInput, FixedEventUncheckedUpdateInput>
  }

  /**
   * FixedEvent delete
   */
  export type FixedEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixedEvent
     */
    select?: FixedEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FixedEvent
     */
    omit?: FixedEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixedEventInclude<ExtArgs> | null
    /**
     * Filter which FixedEvent to delete.
     */
    where: FixedEventWhereUniqueInput
  }

  /**
   * FixedEvent deleteMany
   */
  export type FixedEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FixedEvents to delete
     */
    where?: FixedEventWhereInput
    /**
     * Limit how many FixedEvents to delete.
     */
    limit?: number
  }

  /**
   * FixedEvent without action
   */
  export type FixedEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixedEvent
     */
    select?: FixedEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FixedEvent
     */
    omit?: FixedEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixedEventInclude<ExtArgs> | null
  }


  /**
   * Model WeeklyClass
   */

  export type AggregateWeeklyClass = {
    _count: WeeklyClassCountAggregateOutputType | null
    _avg: WeeklyClassAvgAggregateOutputType | null
    _sum: WeeklyClassSumAggregateOutputType | null
    _min: WeeklyClassMinAggregateOutputType | null
    _max: WeeklyClassMaxAggregateOutputType | null
  }

  export type WeeklyClassAvgAggregateOutputType = {
    day: number | null
  }

  export type WeeklyClassSumAggregateOutputType = {
    day: number | null
  }

  export type WeeklyClassMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    day: number | null
    start: string | null
    end: string | null
    location: string | null
    source: string | null
    externalId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WeeklyClassMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    day: number | null
    start: string | null
    end: string | null
    location: string | null
    source: string | null
    externalId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WeeklyClassCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    day: number
    start: number
    end: number
    location: number
    source: number
    externalId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WeeklyClassAvgAggregateInputType = {
    day?: true
  }

  export type WeeklyClassSumAggregateInputType = {
    day?: true
  }

  export type WeeklyClassMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    day?: true
    start?: true
    end?: true
    location?: true
    source?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WeeklyClassMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    day?: true
    start?: true
    end?: true
    location?: true
    source?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WeeklyClassCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    day?: true
    start?: true
    end?: true
    location?: true
    source?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WeeklyClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeeklyClass to aggregate.
     */
    where?: WeeklyClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyClasses to fetch.
     */
    orderBy?: WeeklyClassOrderByWithRelationInput | WeeklyClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeeklyClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WeeklyClasses
    **/
    _count?: true | WeeklyClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeeklyClassAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeeklyClassSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeeklyClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeeklyClassMaxAggregateInputType
  }

  export type GetWeeklyClassAggregateType<T extends WeeklyClassAggregateArgs> = {
        [P in keyof T & keyof AggregateWeeklyClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeeklyClass[P]>
      : GetScalarType<T[P], AggregateWeeklyClass[P]>
  }




  export type WeeklyClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeeklyClassWhereInput
    orderBy?: WeeklyClassOrderByWithAggregationInput | WeeklyClassOrderByWithAggregationInput[]
    by: WeeklyClassScalarFieldEnum[] | WeeklyClassScalarFieldEnum
    having?: WeeklyClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeeklyClassCountAggregateInputType | true
    _avg?: WeeklyClassAvgAggregateInputType
    _sum?: WeeklyClassSumAggregateInputType
    _min?: WeeklyClassMinAggregateInputType
    _max?: WeeklyClassMaxAggregateInputType
  }

  export type WeeklyClassGroupByOutputType = {
    id: string
    userId: string
    title: string
    day: number
    start: string
    end: string
    location: string | null
    source: string
    externalId: string | null
    createdAt: Date
    updatedAt: Date
    _count: WeeklyClassCountAggregateOutputType | null
    _avg: WeeklyClassAvgAggregateOutputType | null
    _sum: WeeklyClassSumAggregateOutputType | null
    _min: WeeklyClassMinAggregateOutputType | null
    _max: WeeklyClassMaxAggregateOutputType | null
  }

  type GetWeeklyClassGroupByPayload<T extends WeeklyClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeeklyClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeeklyClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeeklyClassGroupByOutputType[P]>
            : GetScalarType<T[P], WeeklyClassGroupByOutputType[P]>
        }
      >
    >


  export type WeeklyClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    day?: boolean
    start?: boolean
    end?: boolean
    location?: boolean
    source?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weeklyClass"]>

  export type WeeklyClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    day?: boolean
    start?: boolean
    end?: boolean
    location?: boolean
    source?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weeklyClass"]>

  export type WeeklyClassSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    day?: boolean
    start?: boolean
    end?: boolean
    location?: boolean
    source?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weeklyClass"]>

  export type WeeklyClassSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    day?: boolean
    start?: boolean
    end?: boolean
    location?: boolean
    source?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WeeklyClassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "day" | "start" | "end" | "location" | "source" | "externalId" | "createdAt" | "updatedAt", ExtArgs["result"]["weeklyClass"]>
  export type WeeklyClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WeeklyClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WeeklyClassIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WeeklyClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WeeklyClass"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      day: number
      start: string
      end: string
      location: string | null
      source: string
      externalId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["weeklyClass"]>
    composites: {}
  }

  type WeeklyClassGetPayload<S extends boolean | null | undefined | WeeklyClassDefaultArgs> = $Result.GetResult<Prisma.$WeeklyClassPayload, S>

  type WeeklyClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeeklyClassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WeeklyClassCountAggregateInputType | true
    }

  export interface WeeklyClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WeeklyClass'], meta: { name: 'WeeklyClass' } }
    /**
     * Find zero or one WeeklyClass that matches the filter.
     * @param {WeeklyClassFindUniqueArgs} args - Arguments to find a WeeklyClass
     * @example
     * // Get one WeeklyClass
     * const weeklyClass = await prisma.weeklyClass.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeeklyClassFindUniqueArgs>(args: SelectSubset<T, WeeklyClassFindUniqueArgs<ExtArgs>>): Prisma__WeeklyClassClient<$Result.GetResult<Prisma.$WeeklyClassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WeeklyClass that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeeklyClassFindUniqueOrThrowArgs} args - Arguments to find a WeeklyClass
     * @example
     * // Get one WeeklyClass
     * const weeklyClass = await prisma.weeklyClass.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeeklyClassFindUniqueOrThrowArgs>(args: SelectSubset<T, WeeklyClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeeklyClassClient<$Result.GetResult<Prisma.$WeeklyClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WeeklyClass that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyClassFindFirstArgs} args - Arguments to find a WeeklyClass
     * @example
     * // Get one WeeklyClass
     * const weeklyClass = await prisma.weeklyClass.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeeklyClassFindFirstArgs>(args?: SelectSubset<T, WeeklyClassFindFirstArgs<ExtArgs>>): Prisma__WeeklyClassClient<$Result.GetResult<Prisma.$WeeklyClassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WeeklyClass that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyClassFindFirstOrThrowArgs} args - Arguments to find a WeeklyClass
     * @example
     * // Get one WeeklyClass
     * const weeklyClass = await prisma.weeklyClass.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeeklyClassFindFirstOrThrowArgs>(args?: SelectSubset<T, WeeklyClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeeklyClassClient<$Result.GetResult<Prisma.$WeeklyClassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WeeklyClasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeeklyClasses
     * const weeklyClasses = await prisma.weeklyClass.findMany()
     * 
     * // Get first 10 WeeklyClasses
     * const weeklyClasses = await prisma.weeklyClass.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weeklyClassWithIdOnly = await prisma.weeklyClass.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeeklyClassFindManyArgs>(args?: SelectSubset<T, WeeklyClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklyClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WeeklyClass.
     * @param {WeeklyClassCreateArgs} args - Arguments to create a WeeklyClass.
     * @example
     * // Create one WeeklyClass
     * const WeeklyClass = await prisma.weeklyClass.create({
     *   data: {
     *     // ... data to create a WeeklyClass
     *   }
     * })
     * 
     */
    create<T extends WeeklyClassCreateArgs>(args: SelectSubset<T, WeeklyClassCreateArgs<ExtArgs>>): Prisma__WeeklyClassClient<$Result.GetResult<Prisma.$WeeklyClassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WeeklyClasses.
     * @param {WeeklyClassCreateManyArgs} args - Arguments to create many WeeklyClasses.
     * @example
     * // Create many WeeklyClasses
     * const weeklyClass = await prisma.weeklyClass.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeeklyClassCreateManyArgs>(args?: SelectSubset<T, WeeklyClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WeeklyClasses and returns the data saved in the database.
     * @param {WeeklyClassCreateManyAndReturnArgs} args - Arguments to create many WeeklyClasses.
     * @example
     * // Create many WeeklyClasses
     * const weeklyClass = await prisma.weeklyClass.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WeeklyClasses and only return the `id`
     * const weeklyClassWithIdOnly = await prisma.weeklyClass.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeeklyClassCreateManyAndReturnArgs>(args?: SelectSubset<T, WeeklyClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklyClassPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WeeklyClass.
     * @param {WeeklyClassDeleteArgs} args - Arguments to delete one WeeklyClass.
     * @example
     * // Delete one WeeklyClass
     * const WeeklyClass = await prisma.weeklyClass.delete({
     *   where: {
     *     // ... filter to delete one WeeklyClass
     *   }
     * })
     * 
     */
    delete<T extends WeeklyClassDeleteArgs>(args: SelectSubset<T, WeeklyClassDeleteArgs<ExtArgs>>): Prisma__WeeklyClassClient<$Result.GetResult<Prisma.$WeeklyClassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WeeklyClass.
     * @param {WeeklyClassUpdateArgs} args - Arguments to update one WeeklyClass.
     * @example
     * // Update one WeeklyClass
     * const weeklyClass = await prisma.weeklyClass.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeeklyClassUpdateArgs>(args: SelectSubset<T, WeeklyClassUpdateArgs<ExtArgs>>): Prisma__WeeklyClassClient<$Result.GetResult<Prisma.$WeeklyClassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WeeklyClasses.
     * @param {WeeklyClassDeleteManyArgs} args - Arguments to filter WeeklyClasses to delete.
     * @example
     * // Delete a few WeeklyClasses
     * const { count } = await prisma.weeklyClass.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeeklyClassDeleteManyArgs>(args?: SelectSubset<T, WeeklyClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeeklyClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeeklyClasses
     * const weeklyClass = await prisma.weeklyClass.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeeklyClassUpdateManyArgs>(args: SelectSubset<T, WeeklyClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeeklyClasses and returns the data updated in the database.
     * @param {WeeklyClassUpdateManyAndReturnArgs} args - Arguments to update many WeeklyClasses.
     * @example
     * // Update many WeeklyClasses
     * const weeklyClass = await prisma.weeklyClass.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WeeklyClasses and only return the `id`
     * const weeklyClassWithIdOnly = await prisma.weeklyClass.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WeeklyClassUpdateManyAndReturnArgs>(args: SelectSubset<T, WeeklyClassUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklyClassPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WeeklyClass.
     * @param {WeeklyClassUpsertArgs} args - Arguments to update or create a WeeklyClass.
     * @example
     * // Update or create a WeeklyClass
     * const weeklyClass = await prisma.weeklyClass.upsert({
     *   create: {
     *     // ... data to create a WeeklyClass
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeeklyClass we want to update
     *   }
     * })
     */
    upsert<T extends WeeklyClassUpsertArgs>(args: SelectSubset<T, WeeklyClassUpsertArgs<ExtArgs>>): Prisma__WeeklyClassClient<$Result.GetResult<Prisma.$WeeklyClassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WeeklyClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyClassCountArgs} args - Arguments to filter WeeklyClasses to count.
     * @example
     * // Count the number of WeeklyClasses
     * const count = await prisma.weeklyClass.count({
     *   where: {
     *     // ... the filter for the WeeklyClasses we want to count
     *   }
     * })
    **/
    count<T extends WeeklyClassCountArgs>(
      args?: Subset<T, WeeklyClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeeklyClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WeeklyClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeeklyClassAggregateArgs>(args: Subset<T, WeeklyClassAggregateArgs>): Prisma.PrismaPromise<GetWeeklyClassAggregateType<T>>

    /**
     * Group by WeeklyClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeeklyClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeeklyClassGroupByArgs['orderBy'] }
        : { orderBy?: WeeklyClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeeklyClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeeklyClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WeeklyClass model
   */
  readonly fields: WeeklyClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WeeklyClass.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeeklyClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WeeklyClass model
   */
  interface WeeklyClassFieldRefs {
    readonly id: FieldRef<"WeeklyClass", 'String'>
    readonly userId: FieldRef<"WeeklyClass", 'String'>
    readonly title: FieldRef<"WeeklyClass", 'String'>
    readonly day: FieldRef<"WeeklyClass", 'Int'>
    readonly start: FieldRef<"WeeklyClass", 'String'>
    readonly end: FieldRef<"WeeklyClass", 'String'>
    readonly location: FieldRef<"WeeklyClass", 'String'>
    readonly source: FieldRef<"WeeklyClass", 'String'>
    readonly externalId: FieldRef<"WeeklyClass", 'String'>
    readonly createdAt: FieldRef<"WeeklyClass", 'DateTime'>
    readonly updatedAt: FieldRef<"WeeklyClass", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WeeklyClass findUnique
   */
  export type WeeklyClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyClass
     */
    select?: WeeklyClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyClass
     */
    omit?: WeeklyClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyClassInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyClass to fetch.
     */
    where: WeeklyClassWhereUniqueInput
  }

  /**
   * WeeklyClass findUniqueOrThrow
   */
  export type WeeklyClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyClass
     */
    select?: WeeklyClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyClass
     */
    omit?: WeeklyClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyClassInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyClass to fetch.
     */
    where: WeeklyClassWhereUniqueInput
  }

  /**
   * WeeklyClass findFirst
   */
  export type WeeklyClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyClass
     */
    select?: WeeklyClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyClass
     */
    omit?: WeeklyClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyClassInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyClass to fetch.
     */
    where?: WeeklyClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyClasses to fetch.
     */
    orderBy?: WeeklyClassOrderByWithRelationInput | WeeklyClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeeklyClasses.
     */
    cursor?: WeeklyClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeeklyClasses.
     */
    distinct?: WeeklyClassScalarFieldEnum | WeeklyClassScalarFieldEnum[]
  }

  /**
   * WeeklyClass findFirstOrThrow
   */
  export type WeeklyClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyClass
     */
    select?: WeeklyClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyClass
     */
    omit?: WeeklyClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyClassInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyClass to fetch.
     */
    where?: WeeklyClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyClasses to fetch.
     */
    orderBy?: WeeklyClassOrderByWithRelationInput | WeeklyClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeeklyClasses.
     */
    cursor?: WeeklyClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeeklyClasses.
     */
    distinct?: WeeklyClassScalarFieldEnum | WeeklyClassScalarFieldEnum[]
  }

  /**
   * WeeklyClass findMany
   */
  export type WeeklyClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyClass
     */
    select?: WeeklyClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyClass
     */
    omit?: WeeklyClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyClassInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyClasses to fetch.
     */
    where?: WeeklyClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyClasses to fetch.
     */
    orderBy?: WeeklyClassOrderByWithRelationInput | WeeklyClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WeeklyClasses.
     */
    cursor?: WeeklyClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyClasses.
     */
    skip?: number
    distinct?: WeeklyClassScalarFieldEnum | WeeklyClassScalarFieldEnum[]
  }

  /**
   * WeeklyClass create
   */
  export type WeeklyClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyClass
     */
    select?: WeeklyClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyClass
     */
    omit?: WeeklyClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyClassInclude<ExtArgs> | null
    /**
     * The data needed to create a WeeklyClass.
     */
    data: XOR<WeeklyClassCreateInput, WeeklyClassUncheckedCreateInput>
  }

  /**
   * WeeklyClass createMany
   */
  export type WeeklyClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WeeklyClasses.
     */
    data: WeeklyClassCreateManyInput | WeeklyClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeeklyClass createManyAndReturn
   */
  export type WeeklyClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyClass
     */
    select?: WeeklyClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyClass
     */
    omit?: WeeklyClassOmit<ExtArgs> | null
    /**
     * The data used to create many WeeklyClasses.
     */
    data: WeeklyClassCreateManyInput | WeeklyClassCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyClassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WeeklyClass update
   */
  export type WeeklyClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyClass
     */
    select?: WeeklyClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyClass
     */
    omit?: WeeklyClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyClassInclude<ExtArgs> | null
    /**
     * The data needed to update a WeeklyClass.
     */
    data: XOR<WeeklyClassUpdateInput, WeeklyClassUncheckedUpdateInput>
    /**
     * Choose, which WeeklyClass to update.
     */
    where: WeeklyClassWhereUniqueInput
  }

  /**
   * WeeklyClass updateMany
   */
  export type WeeklyClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WeeklyClasses.
     */
    data: XOR<WeeklyClassUpdateManyMutationInput, WeeklyClassUncheckedUpdateManyInput>
    /**
     * Filter which WeeklyClasses to update
     */
    where?: WeeklyClassWhereInput
    /**
     * Limit how many WeeklyClasses to update.
     */
    limit?: number
  }

  /**
   * WeeklyClass updateManyAndReturn
   */
  export type WeeklyClassUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyClass
     */
    select?: WeeklyClassSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyClass
     */
    omit?: WeeklyClassOmit<ExtArgs> | null
    /**
     * The data used to update WeeklyClasses.
     */
    data: XOR<WeeklyClassUpdateManyMutationInput, WeeklyClassUncheckedUpdateManyInput>
    /**
     * Filter which WeeklyClasses to update
     */
    where?: WeeklyClassWhereInput
    /**
     * Limit how many WeeklyClasses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyClassIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WeeklyClass upsert
   */
  export type WeeklyClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyClass
     */
    select?: WeeklyClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyClass
     */
    omit?: WeeklyClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyClassInclude<ExtArgs> | null
    /**
     * The filter to search for the WeeklyClass to update in case it exists.
     */
    where: WeeklyClassWhereUniqueInput
    /**
     * In case the WeeklyClass found by the `where` argument doesn't exist, create a new WeeklyClass with this data.
     */
    create: XOR<WeeklyClassCreateInput, WeeklyClassUncheckedCreateInput>
    /**
     * In case the WeeklyClass was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeeklyClassUpdateInput, WeeklyClassUncheckedUpdateInput>
  }

  /**
   * WeeklyClass delete
   */
  export type WeeklyClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyClass
     */
    select?: WeeklyClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyClass
     */
    omit?: WeeklyClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyClassInclude<ExtArgs> | null
    /**
     * Filter which WeeklyClass to delete.
     */
    where: WeeklyClassWhereUniqueInput
  }

  /**
   * WeeklyClass deleteMany
   */
  export type WeeklyClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeeklyClasses to delete
     */
    where?: WeeklyClassWhereInput
    /**
     * Limit how many WeeklyClasses to delete.
     */
    limit?: number
  }

  /**
   * WeeklyClass without action
   */
  export type WeeklyClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyClass
     */
    select?: WeeklyClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyClass
     */
    omit?: WeeklyClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyClassInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    passwordHash: 'passwordHash',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    description: 'description',
    deadline: 'deadline',
    difficulty: 'difficulty',
    priority: 'priority',
    remainingHours: 'remainingHours',
    status: 'status',
    source: 'source',
    externalId: 'externalId',
    completedAt: 'completedAt',
    completionXpAwarded: 'completionXpAwarded',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const StudyBlockScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    taskId: 'taskId',
    start: 'start',
    end: 'end',
    source: 'source',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudyBlockScalarFieldEnum = (typeof StudyBlockScalarFieldEnum)[keyof typeof StudyBlockScalarFieldEnum]


  export const StudySessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    taskId: 'taskId',
    blockId: 'blockId',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    status: 'status',
    focusedMinutes: 'focusedMinutes',
    xpEarned: 'xpEarned'
  };

  export type StudySessionScalarFieldEnum = (typeof StudySessionScalarFieldEnum)[keyof typeof StudySessionScalarFieldEnum]


  export const RewardScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    label: 'label',
    detail: 'detail',
    costXp: 'costXp',
    claimedAt: 'claimedAt'
  };

  export type RewardScalarFieldEnum = (typeof RewardScalarFieldEnum)[keyof typeof RewardScalarFieldEnum]


  export const UserStatsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    totalXp: 'totalXp',
    weeklyXp: 'weeklyXp',
    streak: 'streak',
    level: 'level',
    dailyBaseXp: 'dailyBaseXp',
    dailyXp: 'dailyXp',
    dailyDate: 'dailyDate',
    lastSessionAt: 'lastSessionAt'
  };

  export type UserStatsScalarFieldEnum = (typeof UserStatsScalarFieldEnum)[keyof typeof UserStatsScalarFieldEnum]


  export const IntegrationCanvasScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tokenEncrypted: 'tokenEncrypted',
    canvasBaseUrl: 'canvasBaseUrl',
    canvasUserId: 'canvasUserId',
    lastImportedAt: 'lastImportedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntegrationCanvasScalarFieldEnum = (typeof IntegrationCanvasScalarFieldEnum)[keyof typeof IntegrationCanvasScalarFieldEnum]


  export const FixedEventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    type: 'type',
    start: 'start',
    end: 'end',
    notes: 'notes',
    source: 'source',
    externalId: 'externalId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FixedEventScalarFieldEnum = (typeof FixedEventScalarFieldEnum)[keyof typeof FixedEventScalarFieldEnum]


  export const WeeklyClassScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    day: 'day',
    start: 'start',
    end: 'end',
    location: 'location',
    source: 'source',
    externalId: 'externalId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WeeklyClassScalarFieldEnum = (typeof WeeklyClassScalarFieldEnum)[keyof typeof WeeklyClassScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tasks?: TaskListRelationFilter
    studyBlocks?: StudyBlockListRelationFilter
    studySessions?: StudySessionListRelationFilter
    rewards?: RewardListRelationFilter
    stats?: XOR<UserStatsNullableScalarRelationFilter, UserStatsWhereInput> | null
    integrationCanvas?: XOR<IntegrationCanvasNullableScalarRelationFilter, IntegrationCanvasWhereInput> | null
    weeklyClasses?: WeeklyClassListRelationFilter
    fixedEvents?: FixedEventListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tasks?: TaskOrderByRelationAggregateInput
    studyBlocks?: StudyBlockOrderByRelationAggregateInput
    studySessions?: StudySessionOrderByRelationAggregateInput
    rewards?: RewardOrderByRelationAggregateInput
    stats?: UserStatsOrderByWithRelationInput
    integrationCanvas?: IntegrationCanvasOrderByWithRelationInput
    weeklyClasses?: WeeklyClassOrderByRelationAggregateInput
    fixedEvents?: FixedEventOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tasks?: TaskListRelationFilter
    studyBlocks?: StudyBlockListRelationFilter
    studySessions?: StudySessionListRelationFilter
    rewards?: RewardListRelationFilter
    stats?: XOR<UserStatsNullableScalarRelationFilter, UserStatsWhereInput> | null
    integrationCanvas?: XOR<IntegrationCanvasNullableScalarRelationFilter, IntegrationCanvasWhereInput> | null
    weeklyClasses?: WeeklyClassListRelationFilter
    fixedEvents?: FixedEventListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    userId?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    deadline?: DateTimeNullableFilter<"Task"> | Date | string | null
    difficulty?: StringFilter<"Task"> | string
    priority?: IntFilter<"Task"> | number
    remainingHours?: IntFilter<"Task"> | number
    status?: StringFilter<"Task"> | string
    source?: StringFilter<"Task"> | string
    externalId?: StringNullableFilter<"Task"> | string | null
    completedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    completionXpAwarded?: BoolFilter<"Task"> | boolean
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    studyBlocks?: StudyBlockListRelationFilter
    studySessions?: StudySessionListRelationFilter
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    deadline?: SortOrderInput | SortOrder
    difficulty?: SortOrder
    priority?: SortOrder
    remainingHours?: SortOrder
    status?: SortOrder
    source?: SortOrder
    externalId?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    completionXpAwarded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    studyBlocks?: StudyBlockOrderByRelationAggregateInput
    studySessions?: StudySessionOrderByRelationAggregateInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    userId?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    deadline?: DateTimeNullableFilter<"Task"> | Date | string | null
    difficulty?: StringFilter<"Task"> | string
    priority?: IntFilter<"Task"> | number
    remainingHours?: IntFilter<"Task"> | number
    status?: StringFilter<"Task"> | string
    source?: StringFilter<"Task"> | string
    externalId?: StringNullableFilter<"Task"> | string | null
    completedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    completionXpAwarded?: BoolFilter<"Task"> | boolean
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    studyBlocks?: StudyBlockListRelationFilter
    studySessions?: StudySessionListRelationFilter
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    deadline?: SortOrderInput | SortOrder
    difficulty?: SortOrder
    priority?: SortOrder
    remainingHours?: SortOrder
    status?: SortOrder
    source?: SortOrder
    externalId?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    completionXpAwarded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _avg?: TaskAvgOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
    _sum?: TaskSumOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    userId?: StringWithAggregatesFilter<"Task"> | string
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    deadline?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    difficulty?: StringWithAggregatesFilter<"Task"> | string
    priority?: IntWithAggregatesFilter<"Task"> | number
    remainingHours?: IntWithAggregatesFilter<"Task"> | number
    status?: StringWithAggregatesFilter<"Task"> | string
    source?: StringWithAggregatesFilter<"Task"> | string
    externalId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    completionXpAwarded?: BoolWithAggregatesFilter<"Task"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
  }

  export type StudyBlockWhereInput = {
    AND?: StudyBlockWhereInput | StudyBlockWhereInput[]
    OR?: StudyBlockWhereInput[]
    NOT?: StudyBlockWhereInput | StudyBlockWhereInput[]
    id?: StringFilter<"StudyBlock"> | string
    userId?: StringFilter<"StudyBlock"> | string
    taskId?: StringNullableFilter<"StudyBlock"> | string | null
    start?: DateTimeFilter<"StudyBlock"> | Date | string
    end?: DateTimeFilter<"StudyBlock"> | Date | string
    source?: StringFilter<"StudyBlock"> | string
    status?: StringFilter<"StudyBlock"> | string
    createdAt?: DateTimeFilter<"StudyBlock"> | Date | string
    updatedAt?: DateTimeFilter<"StudyBlock"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    task?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null
    studySession?: XOR<StudySessionNullableScalarRelationFilter, StudySessionWhereInput> | null
  }

  export type StudyBlockOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrderInput | SortOrder
    start?: SortOrder
    end?: SortOrder
    source?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    task?: TaskOrderByWithRelationInput
    studySession?: StudySessionOrderByWithRelationInput
  }

  export type StudyBlockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudyBlockWhereInput | StudyBlockWhereInput[]
    OR?: StudyBlockWhereInput[]
    NOT?: StudyBlockWhereInput | StudyBlockWhereInput[]
    userId?: StringFilter<"StudyBlock"> | string
    taskId?: StringNullableFilter<"StudyBlock"> | string | null
    start?: DateTimeFilter<"StudyBlock"> | Date | string
    end?: DateTimeFilter<"StudyBlock"> | Date | string
    source?: StringFilter<"StudyBlock"> | string
    status?: StringFilter<"StudyBlock"> | string
    createdAt?: DateTimeFilter<"StudyBlock"> | Date | string
    updatedAt?: DateTimeFilter<"StudyBlock"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    task?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null
    studySession?: XOR<StudySessionNullableScalarRelationFilter, StudySessionWhereInput> | null
  }, "id">

  export type StudyBlockOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrderInput | SortOrder
    start?: SortOrder
    end?: SortOrder
    source?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudyBlockCountOrderByAggregateInput
    _max?: StudyBlockMaxOrderByAggregateInput
    _min?: StudyBlockMinOrderByAggregateInput
  }

  export type StudyBlockScalarWhereWithAggregatesInput = {
    AND?: StudyBlockScalarWhereWithAggregatesInput | StudyBlockScalarWhereWithAggregatesInput[]
    OR?: StudyBlockScalarWhereWithAggregatesInput[]
    NOT?: StudyBlockScalarWhereWithAggregatesInput | StudyBlockScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudyBlock"> | string
    userId?: StringWithAggregatesFilter<"StudyBlock"> | string
    taskId?: StringNullableWithAggregatesFilter<"StudyBlock"> | string | null
    start?: DateTimeWithAggregatesFilter<"StudyBlock"> | Date | string
    end?: DateTimeWithAggregatesFilter<"StudyBlock"> | Date | string
    source?: StringWithAggregatesFilter<"StudyBlock"> | string
    status?: StringWithAggregatesFilter<"StudyBlock"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StudyBlock"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudyBlock"> | Date | string
  }

  export type StudySessionWhereInput = {
    AND?: StudySessionWhereInput | StudySessionWhereInput[]
    OR?: StudySessionWhereInput[]
    NOT?: StudySessionWhereInput | StudySessionWhereInput[]
    id?: StringFilter<"StudySession"> | string
    userId?: StringFilter<"StudySession"> | string
    taskId?: StringNullableFilter<"StudySession"> | string | null
    blockId?: StringNullableFilter<"StudySession"> | string | null
    startedAt?: DateTimeFilter<"StudySession"> | Date | string
    endedAt?: DateTimeNullableFilter<"StudySession"> | Date | string | null
    status?: StringFilter<"StudySession"> | string
    focusedMinutes?: IntFilter<"StudySession"> | number
    xpEarned?: IntFilter<"StudySession"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    task?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null
    block?: XOR<StudyBlockNullableScalarRelationFilter, StudyBlockWhereInput> | null
  }

  export type StudySessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrderInput | SortOrder
    blockId?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    focusedMinutes?: SortOrder
    xpEarned?: SortOrder
    user?: UserOrderByWithRelationInput
    task?: TaskOrderByWithRelationInput
    block?: StudyBlockOrderByWithRelationInput
  }

  export type StudySessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    blockId?: string
    AND?: StudySessionWhereInput | StudySessionWhereInput[]
    OR?: StudySessionWhereInput[]
    NOT?: StudySessionWhereInput | StudySessionWhereInput[]
    userId?: StringFilter<"StudySession"> | string
    taskId?: StringNullableFilter<"StudySession"> | string | null
    startedAt?: DateTimeFilter<"StudySession"> | Date | string
    endedAt?: DateTimeNullableFilter<"StudySession"> | Date | string | null
    status?: StringFilter<"StudySession"> | string
    focusedMinutes?: IntFilter<"StudySession"> | number
    xpEarned?: IntFilter<"StudySession"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    task?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null
    block?: XOR<StudyBlockNullableScalarRelationFilter, StudyBlockWhereInput> | null
  }, "id" | "blockId">

  export type StudySessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrderInput | SortOrder
    blockId?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    focusedMinutes?: SortOrder
    xpEarned?: SortOrder
    _count?: StudySessionCountOrderByAggregateInput
    _avg?: StudySessionAvgOrderByAggregateInput
    _max?: StudySessionMaxOrderByAggregateInput
    _min?: StudySessionMinOrderByAggregateInput
    _sum?: StudySessionSumOrderByAggregateInput
  }

  export type StudySessionScalarWhereWithAggregatesInput = {
    AND?: StudySessionScalarWhereWithAggregatesInput | StudySessionScalarWhereWithAggregatesInput[]
    OR?: StudySessionScalarWhereWithAggregatesInput[]
    NOT?: StudySessionScalarWhereWithAggregatesInput | StudySessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudySession"> | string
    userId?: StringWithAggregatesFilter<"StudySession"> | string
    taskId?: StringNullableWithAggregatesFilter<"StudySession"> | string | null
    blockId?: StringNullableWithAggregatesFilter<"StudySession"> | string | null
    startedAt?: DateTimeWithAggregatesFilter<"StudySession"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"StudySession"> | Date | string | null
    status?: StringWithAggregatesFilter<"StudySession"> | string
    focusedMinutes?: IntWithAggregatesFilter<"StudySession"> | number
    xpEarned?: IntWithAggregatesFilter<"StudySession"> | number
  }

  export type RewardWhereInput = {
    AND?: RewardWhereInput | RewardWhereInput[]
    OR?: RewardWhereInput[]
    NOT?: RewardWhereInput | RewardWhereInput[]
    id?: StringFilter<"Reward"> | string
    userId?: StringFilter<"Reward"> | string
    label?: StringFilter<"Reward"> | string
    detail?: StringNullableFilter<"Reward"> | string | null
    costXp?: IntFilter<"Reward"> | number
    claimedAt?: DateTimeNullableFilter<"Reward"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RewardOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    label?: SortOrder
    detail?: SortOrderInput | SortOrder
    costXp?: SortOrder
    claimedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RewardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RewardWhereInput | RewardWhereInput[]
    OR?: RewardWhereInput[]
    NOT?: RewardWhereInput | RewardWhereInput[]
    userId?: StringFilter<"Reward"> | string
    label?: StringFilter<"Reward"> | string
    detail?: StringNullableFilter<"Reward"> | string | null
    costXp?: IntFilter<"Reward"> | number
    claimedAt?: DateTimeNullableFilter<"Reward"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type RewardOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    label?: SortOrder
    detail?: SortOrderInput | SortOrder
    costXp?: SortOrder
    claimedAt?: SortOrderInput | SortOrder
    _count?: RewardCountOrderByAggregateInput
    _avg?: RewardAvgOrderByAggregateInput
    _max?: RewardMaxOrderByAggregateInput
    _min?: RewardMinOrderByAggregateInput
    _sum?: RewardSumOrderByAggregateInput
  }

  export type RewardScalarWhereWithAggregatesInput = {
    AND?: RewardScalarWhereWithAggregatesInput | RewardScalarWhereWithAggregatesInput[]
    OR?: RewardScalarWhereWithAggregatesInput[]
    NOT?: RewardScalarWhereWithAggregatesInput | RewardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reward"> | string
    userId?: StringWithAggregatesFilter<"Reward"> | string
    label?: StringWithAggregatesFilter<"Reward"> | string
    detail?: StringNullableWithAggregatesFilter<"Reward"> | string | null
    costXp?: IntWithAggregatesFilter<"Reward"> | number
    claimedAt?: DateTimeNullableWithAggregatesFilter<"Reward"> | Date | string | null
  }

  export type UserStatsWhereInput = {
    AND?: UserStatsWhereInput | UserStatsWhereInput[]
    OR?: UserStatsWhereInput[]
    NOT?: UserStatsWhereInput | UserStatsWhereInput[]
    id?: StringFilter<"UserStats"> | string
    userId?: StringFilter<"UserStats"> | string
    totalXp?: IntFilter<"UserStats"> | number
    weeklyXp?: IntFilter<"UserStats"> | number
    streak?: IntFilter<"UserStats"> | number
    level?: IntFilter<"UserStats"> | number
    dailyBaseXp?: IntFilter<"UserStats"> | number
    dailyXp?: IntFilter<"UserStats"> | number
    dailyDate?: DateTimeNullableFilter<"UserStats"> | Date | string | null
    lastSessionAt?: DateTimeNullableFilter<"UserStats"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserStatsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    totalXp?: SortOrder
    weeklyXp?: SortOrder
    streak?: SortOrder
    level?: SortOrder
    dailyBaseXp?: SortOrder
    dailyXp?: SortOrder
    dailyDate?: SortOrderInput | SortOrder
    lastSessionAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserStatsWhereInput | UserStatsWhereInput[]
    OR?: UserStatsWhereInput[]
    NOT?: UserStatsWhereInput | UserStatsWhereInput[]
    totalXp?: IntFilter<"UserStats"> | number
    weeklyXp?: IntFilter<"UserStats"> | number
    streak?: IntFilter<"UserStats"> | number
    level?: IntFilter<"UserStats"> | number
    dailyBaseXp?: IntFilter<"UserStats"> | number
    dailyXp?: IntFilter<"UserStats"> | number
    dailyDate?: DateTimeNullableFilter<"UserStats"> | Date | string | null
    lastSessionAt?: DateTimeNullableFilter<"UserStats"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserStatsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    totalXp?: SortOrder
    weeklyXp?: SortOrder
    streak?: SortOrder
    level?: SortOrder
    dailyBaseXp?: SortOrder
    dailyXp?: SortOrder
    dailyDate?: SortOrderInput | SortOrder
    lastSessionAt?: SortOrderInput | SortOrder
    _count?: UserStatsCountOrderByAggregateInput
    _avg?: UserStatsAvgOrderByAggregateInput
    _max?: UserStatsMaxOrderByAggregateInput
    _min?: UserStatsMinOrderByAggregateInput
    _sum?: UserStatsSumOrderByAggregateInput
  }

  export type UserStatsScalarWhereWithAggregatesInput = {
    AND?: UserStatsScalarWhereWithAggregatesInput | UserStatsScalarWhereWithAggregatesInput[]
    OR?: UserStatsScalarWhereWithAggregatesInput[]
    NOT?: UserStatsScalarWhereWithAggregatesInput | UserStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserStats"> | string
    userId?: StringWithAggregatesFilter<"UserStats"> | string
    totalXp?: IntWithAggregatesFilter<"UserStats"> | number
    weeklyXp?: IntWithAggregatesFilter<"UserStats"> | number
    streak?: IntWithAggregatesFilter<"UserStats"> | number
    level?: IntWithAggregatesFilter<"UserStats"> | number
    dailyBaseXp?: IntWithAggregatesFilter<"UserStats"> | number
    dailyXp?: IntWithAggregatesFilter<"UserStats"> | number
    dailyDate?: DateTimeNullableWithAggregatesFilter<"UserStats"> | Date | string | null
    lastSessionAt?: DateTimeNullableWithAggregatesFilter<"UserStats"> | Date | string | null
  }

  export type IntegrationCanvasWhereInput = {
    AND?: IntegrationCanvasWhereInput | IntegrationCanvasWhereInput[]
    OR?: IntegrationCanvasWhereInput[]
    NOT?: IntegrationCanvasWhereInput | IntegrationCanvasWhereInput[]
    id?: StringFilter<"IntegrationCanvas"> | string
    userId?: StringFilter<"IntegrationCanvas"> | string
    tokenEncrypted?: StringNullableFilter<"IntegrationCanvas"> | string | null
    canvasBaseUrl?: StringFilter<"IntegrationCanvas"> | string
    canvasUserId?: StringNullableFilter<"IntegrationCanvas"> | string | null
    lastImportedAt?: DateTimeNullableFilter<"IntegrationCanvas"> | Date | string | null
    createdAt?: DateTimeFilter<"IntegrationCanvas"> | Date | string
    updatedAt?: DateTimeFilter<"IntegrationCanvas"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type IntegrationCanvasOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenEncrypted?: SortOrderInput | SortOrder
    canvasBaseUrl?: SortOrder
    canvasUserId?: SortOrderInput | SortOrder
    lastImportedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type IntegrationCanvasWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: IntegrationCanvasWhereInput | IntegrationCanvasWhereInput[]
    OR?: IntegrationCanvasWhereInput[]
    NOT?: IntegrationCanvasWhereInput | IntegrationCanvasWhereInput[]
    tokenEncrypted?: StringNullableFilter<"IntegrationCanvas"> | string | null
    canvasBaseUrl?: StringFilter<"IntegrationCanvas"> | string
    canvasUserId?: StringNullableFilter<"IntegrationCanvas"> | string | null
    lastImportedAt?: DateTimeNullableFilter<"IntegrationCanvas"> | Date | string | null
    createdAt?: DateTimeFilter<"IntegrationCanvas"> | Date | string
    updatedAt?: DateTimeFilter<"IntegrationCanvas"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type IntegrationCanvasOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenEncrypted?: SortOrderInput | SortOrder
    canvasBaseUrl?: SortOrder
    canvasUserId?: SortOrderInput | SortOrder
    lastImportedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntegrationCanvasCountOrderByAggregateInput
    _max?: IntegrationCanvasMaxOrderByAggregateInput
    _min?: IntegrationCanvasMinOrderByAggregateInput
  }

  export type IntegrationCanvasScalarWhereWithAggregatesInput = {
    AND?: IntegrationCanvasScalarWhereWithAggregatesInput | IntegrationCanvasScalarWhereWithAggregatesInput[]
    OR?: IntegrationCanvasScalarWhereWithAggregatesInput[]
    NOT?: IntegrationCanvasScalarWhereWithAggregatesInput | IntegrationCanvasScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IntegrationCanvas"> | string
    userId?: StringWithAggregatesFilter<"IntegrationCanvas"> | string
    tokenEncrypted?: StringNullableWithAggregatesFilter<"IntegrationCanvas"> | string | null
    canvasBaseUrl?: StringWithAggregatesFilter<"IntegrationCanvas"> | string
    canvasUserId?: StringNullableWithAggregatesFilter<"IntegrationCanvas"> | string | null
    lastImportedAt?: DateTimeNullableWithAggregatesFilter<"IntegrationCanvas"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"IntegrationCanvas"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IntegrationCanvas"> | Date | string
  }

  export type FixedEventWhereInput = {
    AND?: FixedEventWhereInput | FixedEventWhereInput[]
    OR?: FixedEventWhereInput[]
    NOT?: FixedEventWhereInput | FixedEventWhereInput[]
    id?: StringFilter<"FixedEvent"> | string
    userId?: StringFilter<"FixedEvent"> | string
    title?: StringFilter<"FixedEvent"> | string
    type?: StringFilter<"FixedEvent"> | string
    start?: DateTimeFilter<"FixedEvent"> | Date | string
    end?: DateTimeFilter<"FixedEvent"> | Date | string
    notes?: StringNullableFilter<"FixedEvent"> | string | null
    source?: StringFilter<"FixedEvent"> | string
    externalId?: StringNullableFilter<"FixedEvent"> | string | null
    createdAt?: DateTimeFilter<"FixedEvent"> | Date | string
    updatedAt?: DateTimeFilter<"FixedEvent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FixedEventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    start?: SortOrder
    end?: SortOrder
    notes?: SortOrderInput | SortOrder
    source?: SortOrder
    externalId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type FixedEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FixedEventWhereInput | FixedEventWhereInput[]
    OR?: FixedEventWhereInput[]
    NOT?: FixedEventWhereInput | FixedEventWhereInput[]
    userId?: StringFilter<"FixedEvent"> | string
    title?: StringFilter<"FixedEvent"> | string
    type?: StringFilter<"FixedEvent"> | string
    start?: DateTimeFilter<"FixedEvent"> | Date | string
    end?: DateTimeFilter<"FixedEvent"> | Date | string
    notes?: StringNullableFilter<"FixedEvent"> | string | null
    source?: StringFilter<"FixedEvent"> | string
    externalId?: StringNullableFilter<"FixedEvent"> | string | null
    createdAt?: DateTimeFilter<"FixedEvent"> | Date | string
    updatedAt?: DateTimeFilter<"FixedEvent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type FixedEventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    start?: SortOrder
    end?: SortOrder
    notes?: SortOrderInput | SortOrder
    source?: SortOrder
    externalId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FixedEventCountOrderByAggregateInput
    _max?: FixedEventMaxOrderByAggregateInput
    _min?: FixedEventMinOrderByAggregateInput
  }

  export type FixedEventScalarWhereWithAggregatesInput = {
    AND?: FixedEventScalarWhereWithAggregatesInput | FixedEventScalarWhereWithAggregatesInput[]
    OR?: FixedEventScalarWhereWithAggregatesInput[]
    NOT?: FixedEventScalarWhereWithAggregatesInput | FixedEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FixedEvent"> | string
    userId?: StringWithAggregatesFilter<"FixedEvent"> | string
    title?: StringWithAggregatesFilter<"FixedEvent"> | string
    type?: StringWithAggregatesFilter<"FixedEvent"> | string
    start?: DateTimeWithAggregatesFilter<"FixedEvent"> | Date | string
    end?: DateTimeWithAggregatesFilter<"FixedEvent"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"FixedEvent"> | string | null
    source?: StringWithAggregatesFilter<"FixedEvent"> | string
    externalId?: StringNullableWithAggregatesFilter<"FixedEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FixedEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FixedEvent"> | Date | string
  }

  export type WeeklyClassWhereInput = {
    AND?: WeeklyClassWhereInput | WeeklyClassWhereInput[]
    OR?: WeeklyClassWhereInput[]
    NOT?: WeeklyClassWhereInput | WeeklyClassWhereInput[]
    id?: StringFilter<"WeeklyClass"> | string
    userId?: StringFilter<"WeeklyClass"> | string
    title?: StringFilter<"WeeklyClass"> | string
    day?: IntFilter<"WeeklyClass"> | number
    start?: StringFilter<"WeeklyClass"> | string
    end?: StringFilter<"WeeklyClass"> | string
    location?: StringNullableFilter<"WeeklyClass"> | string | null
    source?: StringFilter<"WeeklyClass"> | string
    externalId?: StringNullableFilter<"WeeklyClass"> | string | null
    createdAt?: DateTimeFilter<"WeeklyClass"> | Date | string
    updatedAt?: DateTimeFilter<"WeeklyClass"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type WeeklyClassOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    day?: SortOrder
    start?: SortOrder
    end?: SortOrder
    location?: SortOrderInput | SortOrder
    source?: SortOrder
    externalId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type WeeklyClassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WeeklyClassWhereInput | WeeklyClassWhereInput[]
    OR?: WeeklyClassWhereInput[]
    NOT?: WeeklyClassWhereInput | WeeklyClassWhereInput[]
    userId?: StringFilter<"WeeklyClass"> | string
    title?: StringFilter<"WeeklyClass"> | string
    day?: IntFilter<"WeeklyClass"> | number
    start?: StringFilter<"WeeklyClass"> | string
    end?: StringFilter<"WeeklyClass"> | string
    location?: StringNullableFilter<"WeeklyClass"> | string | null
    source?: StringFilter<"WeeklyClass"> | string
    externalId?: StringNullableFilter<"WeeklyClass"> | string | null
    createdAt?: DateTimeFilter<"WeeklyClass"> | Date | string
    updatedAt?: DateTimeFilter<"WeeklyClass"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type WeeklyClassOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    day?: SortOrder
    start?: SortOrder
    end?: SortOrder
    location?: SortOrderInput | SortOrder
    source?: SortOrder
    externalId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WeeklyClassCountOrderByAggregateInput
    _avg?: WeeklyClassAvgOrderByAggregateInput
    _max?: WeeklyClassMaxOrderByAggregateInput
    _min?: WeeklyClassMinOrderByAggregateInput
    _sum?: WeeklyClassSumOrderByAggregateInput
  }

  export type WeeklyClassScalarWhereWithAggregatesInput = {
    AND?: WeeklyClassScalarWhereWithAggregatesInput | WeeklyClassScalarWhereWithAggregatesInput[]
    OR?: WeeklyClassScalarWhereWithAggregatesInput[]
    NOT?: WeeklyClassScalarWhereWithAggregatesInput | WeeklyClassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WeeklyClass"> | string
    userId?: StringWithAggregatesFilter<"WeeklyClass"> | string
    title?: StringWithAggregatesFilter<"WeeklyClass"> | string
    day?: IntWithAggregatesFilter<"WeeklyClass"> | number
    start?: StringWithAggregatesFilter<"WeeklyClass"> | string
    end?: StringWithAggregatesFilter<"WeeklyClass"> | string
    location?: StringNullableWithAggregatesFilter<"WeeklyClass"> | string | null
    source?: StringWithAggregatesFilter<"WeeklyClass"> | string
    externalId?: StringNullableWithAggregatesFilter<"WeeklyClass"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WeeklyClass"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WeeklyClass"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskCreateNestedManyWithoutUserInput
    studyBlocks?: StudyBlockCreateNestedManyWithoutUserInput
    studySessions?: StudySessionCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
    integrationCanvas?: IntegrationCanvasCreateNestedOneWithoutUserInput
    weeklyClasses?: WeeklyClassCreateNestedManyWithoutUserInput
    fixedEvents?: FixedEventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    studyBlocks?: StudyBlockUncheckedCreateNestedManyWithoutUserInput
    studySessions?: StudySessionUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
    integrationCanvas?: IntegrationCanvasUncheckedCreateNestedOneWithoutUserInput
    weeklyClasses?: WeeklyClassUncheckedCreateNestedManyWithoutUserInput
    fixedEvents?: FixedEventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutUserNestedInput
    studyBlocks?: StudyBlockUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
    integrationCanvas?: IntegrationCanvasUpdateOneWithoutUserNestedInput
    weeklyClasses?: WeeklyClassUpdateManyWithoutUserNestedInput
    fixedEvents?: FixedEventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    studyBlocks?: StudyBlockUncheckedUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
    integrationCanvas?: IntegrationCanvasUncheckedUpdateOneWithoutUserNestedInput
    weeklyClasses?: WeeklyClassUncheckedUpdateManyWithoutUserNestedInput
    fixedEvents?: FixedEventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    deadline?: Date | string | null
    difficulty?: string
    priority?: number
    remainingHours?: number
    status?: string
    source?: string
    externalId?: string | null
    completedAt?: Date | string | null
    completionXpAwarded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTasksInput
    studyBlocks?: StudyBlockCreateNestedManyWithoutTaskInput
    studySessions?: StudySessionCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    deadline?: Date | string | null
    difficulty?: string
    priority?: number
    remainingHours?: number
    status?: string
    source?: string
    externalId?: string | null
    completedAt?: Date | string | null
    completionXpAwarded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studyBlocks?: StudyBlockUncheckedCreateNestedManyWithoutTaskInput
    studySessions?: StudySessionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    remainingHours?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionXpAwarded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
    studyBlocks?: StudyBlockUpdateManyWithoutTaskNestedInput
    studySessions?: StudySessionUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    remainingHours?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionXpAwarded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studyBlocks?: StudyBlockUncheckedUpdateManyWithoutTaskNestedInput
    studySessions?: StudySessionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskCreateManyInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    deadline?: Date | string | null
    difficulty?: string
    priority?: number
    remainingHours?: number
    status?: string
    source?: string
    externalId?: string | null
    completedAt?: Date | string | null
    completionXpAwarded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    remainingHours?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionXpAwarded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    remainingHours?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionXpAwarded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyBlockCreateInput = {
    id?: string
    start: Date | string
    end: Date | string
    source?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudyBlocksInput
    task?: TaskCreateNestedOneWithoutStudyBlocksInput
    studySession?: StudySessionCreateNestedOneWithoutBlockInput
  }

  export type StudyBlockUncheckedCreateInput = {
    id?: string
    userId: string
    taskId?: string | null
    start: Date | string
    end: Date | string
    source?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studySession?: StudySessionUncheckedCreateNestedOneWithoutBlockInput
  }

  export type StudyBlockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudyBlocksNestedInput
    task?: TaskUpdateOneWithoutStudyBlocksNestedInput
    studySession?: StudySessionUpdateOneWithoutBlockNestedInput
  }

  export type StudyBlockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studySession?: StudySessionUncheckedUpdateOneWithoutBlockNestedInput
  }

  export type StudyBlockCreateManyInput = {
    id?: string
    userId: string
    taskId?: string | null
    start: Date | string
    end: Date | string
    source?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudyBlockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyBlockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudySessionCreateInput = {
    id?: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: string
    focusedMinutes?: number
    xpEarned?: number
    user: UserCreateNestedOneWithoutStudySessionsInput
    task?: TaskCreateNestedOneWithoutStudySessionsInput
    block?: StudyBlockCreateNestedOneWithoutStudySessionInput
  }

  export type StudySessionUncheckedCreateInput = {
    id?: string
    userId: string
    taskId?: string | null
    blockId?: string | null
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: string
    focusedMinutes?: number
    xpEarned?: number
  }

  export type StudySessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    focusedMinutes?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutStudySessionsNestedInput
    task?: TaskUpdateOneWithoutStudySessionsNestedInput
    block?: StudyBlockUpdateOneWithoutStudySessionNestedInput
  }

  export type StudySessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    blockId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    focusedMinutes?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
  }

  export type StudySessionCreateManyInput = {
    id?: string
    userId: string
    taskId?: string | null
    blockId?: string | null
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: string
    focusedMinutes?: number
    xpEarned?: number
  }

  export type StudySessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    focusedMinutes?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
  }

  export type StudySessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    blockId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    focusedMinutes?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
  }

  export type RewardCreateInput = {
    id?: string
    label: string
    detail?: string | null
    costXp?: number
    claimedAt?: Date | string | null
    user: UserCreateNestedOneWithoutRewardsInput
  }

  export type RewardUncheckedCreateInput = {
    id?: string
    userId: string
    label: string
    detail?: string | null
    costXp?: number
    claimedAt?: Date | string | null
  }

  export type RewardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    costXp?: IntFieldUpdateOperationsInput | number
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutRewardsNestedInput
  }

  export type RewardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    costXp?: IntFieldUpdateOperationsInput | number
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RewardCreateManyInput = {
    id?: string
    userId: string
    label: string
    detail?: string | null
    costXp?: number
    claimedAt?: Date | string | null
  }

  export type RewardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    costXp?: IntFieldUpdateOperationsInput | number
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RewardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    costXp?: IntFieldUpdateOperationsInput | number
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserStatsCreateInput = {
    id?: string
    totalXp?: number
    weeklyXp?: number
    streak?: number
    level?: number
    dailyBaseXp?: number
    dailyXp?: number
    dailyDate?: Date | string | null
    lastSessionAt?: Date | string | null
    user: UserCreateNestedOneWithoutStatsInput
  }

  export type UserStatsUncheckedCreateInput = {
    id?: string
    userId: string
    totalXp?: number
    weeklyXp?: number
    streak?: number
    level?: number
    dailyBaseXp?: number
    dailyXp?: number
    dailyDate?: Date | string | null
    lastSessionAt?: Date | string | null
  }

  export type UserStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalXp?: IntFieldUpdateOperationsInput | number
    weeklyXp?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    dailyBaseXp?: IntFieldUpdateOperationsInput | number
    dailyXp?: IntFieldUpdateOperationsInput | number
    dailyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSessionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutStatsNestedInput
  }

  export type UserStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalXp?: IntFieldUpdateOperationsInput | number
    weeklyXp?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    dailyBaseXp?: IntFieldUpdateOperationsInput | number
    dailyXp?: IntFieldUpdateOperationsInput | number
    dailyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSessionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserStatsCreateManyInput = {
    id?: string
    userId: string
    totalXp?: number
    weeklyXp?: number
    streak?: number
    level?: number
    dailyBaseXp?: number
    dailyXp?: number
    dailyDate?: Date | string | null
    lastSessionAt?: Date | string | null
  }

  export type UserStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalXp?: IntFieldUpdateOperationsInput | number
    weeklyXp?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    dailyBaseXp?: IntFieldUpdateOperationsInput | number
    dailyXp?: IntFieldUpdateOperationsInput | number
    dailyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSessionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalXp?: IntFieldUpdateOperationsInput | number
    weeklyXp?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    dailyBaseXp?: IntFieldUpdateOperationsInput | number
    dailyXp?: IntFieldUpdateOperationsInput | number
    dailyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSessionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntegrationCanvasCreateInput = {
    id?: string
    tokenEncrypted?: string | null
    canvasBaseUrl: string
    canvasUserId?: string | null
    lastImportedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutIntegrationCanvasInput
  }

  export type IntegrationCanvasUncheckedCreateInput = {
    id?: string
    userId: string
    tokenEncrypted?: string | null
    canvasBaseUrl: string
    canvasUserId?: string | null
    lastImportedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationCanvasUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    canvasBaseUrl?: StringFieldUpdateOperationsInput | string
    canvasUserId?: NullableStringFieldUpdateOperationsInput | string | null
    lastImportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutIntegrationCanvasNestedInput
  }

  export type IntegrationCanvasUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    canvasBaseUrl?: StringFieldUpdateOperationsInput | string
    canvasUserId?: NullableStringFieldUpdateOperationsInput | string | null
    lastImportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationCanvasCreateManyInput = {
    id?: string
    userId: string
    tokenEncrypted?: string | null
    canvasBaseUrl: string
    canvasUserId?: string | null
    lastImportedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationCanvasUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    canvasBaseUrl?: StringFieldUpdateOperationsInput | string
    canvasUserId?: NullableStringFieldUpdateOperationsInput | string | null
    lastImportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationCanvasUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    canvasBaseUrl?: StringFieldUpdateOperationsInput | string
    canvasUserId?: NullableStringFieldUpdateOperationsInput | string | null
    lastImportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FixedEventCreateInput = {
    id?: string
    title: string
    type?: string
    start: Date | string
    end: Date | string
    notes?: string | null
    source?: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFixedEventsInput
  }

  export type FixedEventUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    type?: string
    start: Date | string
    end: Date | string
    notes?: string | null
    source?: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FixedEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFixedEventsNestedInput
  }

  export type FixedEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FixedEventCreateManyInput = {
    id?: string
    userId: string
    title: string
    type?: string
    start: Date | string
    end: Date | string
    notes?: string | null
    source?: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FixedEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FixedEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyClassCreateInput = {
    id?: string
    title: string
    day: number
    start: string
    end: string
    location?: string | null
    source?: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWeeklyClassesInput
  }

  export type WeeklyClassUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    day: number
    start: string
    end: string
    location?: string | null
    source?: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeeklyClassUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    day?: IntFieldUpdateOperationsInput | number
    start?: StringFieldUpdateOperationsInput | string
    end?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWeeklyClassesNestedInput
  }

  export type WeeklyClassUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    day?: IntFieldUpdateOperationsInput | number
    start?: StringFieldUpdateOperationsInput | string
    end?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyClassCreateManyInput = {
    id?: string
    userId: string
    title: string
    day: number
    start: string
    end: string
    location?: string | null
    source?: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeeklyClassUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    day?: IntFieldUpdateOperationsInput | number
    start?: StringFieldUpdateOperationsInput | string
    end?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyClassUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    day?: IntFieldUpdateOperationsInput | number
    start?: StringFieldUpdateOperationsInput | string
    end?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type StudyBlockListRelationFilter = {
    every?: StudyBlockWhereInput
    some?: StudyBlockWhereInput
    none?: StudyBlockWhereInput
  }

  export type StudySessionListRelationFilter = {
    every?: StudySessionWhereInput
    some?: StudySessionWhereInput
    none?: StudySessionWhereInput
  }

  export type RewardListRelationFilter = {
    every?: RewardWhereInput
    some?: RewardWhereInput
    none?: RewardWhereInput
  }

  export type UserStatsNullableScalarRelationFilter = {
    is?: UserStatsWhereInput | null
    isNot?: UserStatsWhereInput | null
  }

  export type IntegrationCanvasNullableScalarRelationFilter = {
    is?: IntegrationCanvasWhereInput | null
    isNot?: IntegrationCanvasWhereInput | null
  }

  export type WeeklyClassListRelationFilter = {
    every?: WeeklyClassWhereInput
    some?: WeeklyClassWhereInput
    none?: WeeklyClassWhereInput
  }

  export type FixedEventListRelationFilter = {
    every?: FixedEventWhereInput
    some?: FixedEventWhereInput
    none?: FixedEventWhereInput
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudyBlockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudySessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RewardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WeeklyClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FixedEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    deadline?: SortOrder
    difficulty?: SortOrder
    priority?: SortOrder
    remainingHours?: SortOrder
    status?: SortOrder
    source?: SortOrder
    externalId?: SortOrder
    completedAt?: SortOrder
    completionXpAwarded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskAvgOrderByAggregateInput = {
    priority?: SortOrder
    remainingHours?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    deadline?: SortOrder
    difficulty?: SortOrder
    priority?: SortOrder
    remainingHours?: SortOrder
    status?: SortOrder
    source?: SortOrder
    externalId?: SortOrder
    completedAt?: SortOrder
    completionXpAwarded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    deadline?: SortOrder
    difficulty?: SortOrder
    priority?: SortOrder
    remainingHours?: SortOrder
    status?: SortOrder
    source?: SortOrder
    externalId?: SortOrder
    completedAt?: SortOrder
    completionXpAwarded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskSumOrderByAggregateInput = {
    priority?: SortOrder
    remainingHours?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type TaskNullableScalarRelationFilter = {
    is?: TaskWhereInput | null
    isNot?: TaskWhereInput | null
  }

  export type StudySessionNullableScalarRelationFilter = {
    is?: StudySessionWhereInput | null
    isNot?: StudySessionWhereInput | null
  }

  export type StudyBlockCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    start?: SortOrder
    end?: SortOrder
    source?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudyBlockMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    start?: SortOrder
    end?: SortOrder
    source?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudyBlockMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    start?: SortOrder
    end?: SortOrder
    source?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudyBlockNullableScalarRelationFilter = {
    is?: StudyBlockWhereInput | null
    isNot?: StudyBlockWhereInput | null
  }

  export type StudySessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    blockId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    status?: SortOrder
    focusedMinutes?: SortOrder
    xpEarned?: SortOrder
  }

  export type StudySessionAvgOrderByAggregateInput = {
    focusedMinutes?: SortOrder
    xpEarned?: SortOrder
  }

  export type StudySessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    blockId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    status?: SortOrder
    focusedMinutes?: SortOrder
    xpEarned?: SortOrder
  }

  export type StudySessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    blockId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    status?: SortOrder
    focusedMinutes?: SortOrder
    xpEarned?: SortOrder
  }

  export type StudySessionSumOrderByAggregateInput = {
    focusedMinutes?: SortOrder
    xpEarned?: SortOrder
  }

  export type RewardCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    label?: SortOrder
    detail?: SortOrder
    costXp?: SortOrder
    claimedAt?: SortOrder
  }

  export type RewardAvgOrderByAggregateInput = {
    costXp?: SortOrder
  }

  export type RewardMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    label?: SortOrder
    detail?: SortOrder
    costXp?: SortOrder
    claimedAt?: SortOrder
  }

  export type RewardMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    label?: SortOrder
    detail?: SortOrder
    costXp?: SortOrder
    claimedAt?: SortOrder
  }

  export type RewardSumOrderByAggregateInput = {
    costXp?: SortOrder
  }

  export type UserStatsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalXp?: SortOrder
    weeklyXp?: SortOrder
    streak?: SortOrder
    level?: SortOrder
    dailyBaseXp?: SortOrder
    dailyXp?: SortOrder
    dailyDate?: SortOrder
    lastSessionAt?: SortOrder
  }

  export type UserStatsAvgOrderByAggregateInput = {
    totalXp?: SortOrder
    weeklyXp?: SortOrder
    streak?: SortOrder
    level?: SortOrder
    dailyBaseXp?: SortOrder
    dailyXp?: SortOrder
  }

  export type UserStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalXp?: SortOrder
    weeklyXp?: SortOrder
    streak?: SortOrder
    level?: SortOrder
    dailyBaseXp?: SortOrder
    dailyXp?: SortOrder
    dailyDate?: SortOrder
    lastSessionAt?: SortOrder
  }

  export type UserStatsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalXp?: SortOrder
    weeklyXp?: SortOrder
    streak?: SortOrder
    level?: SortOrder
    dailyBaseXp?: SortOrder
    dailyXp?: SortOrder
    dailyDate?: SortOrder
    lastSessionAt?: SortOrder
  }

  export type UserStatsSumOrderByAggregateInput = {
    totalXp?: SortOrder
    weeklyXp?: SortOrder
    streak?: SortOrder
    level?: SortOrder
    dailyBaseXp?: SortOrder
    dailyXp?: SortOrder
  }

  export type IntegrationCanvasCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenEncrypted?: SortOrder
    canvasBaseUrl?: SortOrder
    canvasUserId?: SortOrder
    lastImportedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationCanvasMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenEncrypted?: SortOrder
    canvasBaseUrl?: SortOrder
    canvasUserId?: SortOrder
    lastImportedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationCanvasMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenEncrypted?: SortOrder
    canvasBaseUrl?: SortOrder
    canvasUserId?: SortOrder
    lastImportedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FixedEventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    start?: SortOrder
    end?: SortOrder
    notes?: SortOrder
    source?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FixedEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    start?: SortOrder
    end?: SortOrder
    notes?: SortOrder
    source?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FixedEventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    start?: SortOrder
    end?: SortOrder
    notes?: SortOrder
    source?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeeklyClassCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    day?: SortOrder
    start?: SortOrder
    end?: SortOrder
    location?: SortOrder
    source?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeeklyClassAvgOrderByAggregateInput = {
    day?: SortOrder
  }

  export type WeeklyClassMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    day?: SortOrder
    start?: SortOrder
    end?: SortOrder
    location?: SortOrder
    source?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeeklyClassMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    day?: SortOrder
    start?: SortOrder
    end?: SortOrder
    location?: SortOrder
    source?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeeklyClassSumOrderByAggregateInput = {
    day?: SortOrder
  }

  export type TaskCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput> | TaskCreateWithoutUserInput[] | TaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUserInput | TaskCreateOrConnectWithoutUserInput[]
    createMany?: TaskCreateManyUserInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type StudyBlockCreateNestedManyWithoutUserInput = {
    create?: XOR<StudyBlockCreateWithoutUserInput, StudyBlockUncheckedCreateWithoutUserInput> | StudyBlockCreateWithoutUserInput[] | StudyBlockUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudyBlockCreateOrConnectWithoutUserInput | StudyBlockCreateOrConnectWithoutUserInput[]
    createMany?: StudyBlockCreateManyUserInputEnvelope
    connect?: StudyBlockWhereUniqueInput | StudyBlockWhereUniqueInput[]
  }

  export type StudySessionCreateNestedManyWithoutUserInput = {
    create?: XOR<StudySessionCreateWithoutUserInput, StudySessionUncheckedCreateWithoutUserInput> | StudySessionCreateWithoutUserInput[] | StudySessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudySessionCreateOrConnectWithoutUserInput | StudySessionCreateOrConnectWithoutUserInput[]
    createMany?: StudySessionCreateManyUserInputEnvelope
    connect?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
  }

  export type RewardCreateNestedManyWithoutUserInput = {
    create?: XOR<RewardCreateWithoutUserInput, RewardUncheckedCreateWithoutUserInput> | RewardCreateWithoutUserInput[] | RewardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RewardCreateOrConnectWithoutUserInput | RewardCreateOrConnectWithoutUserInput[]
    createMany?: RewardCreateManyUserInputEnvelope
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
  }

  export type UserStatsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserStatsCreateWithoutUserInput, UserStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserStatsCreateOrConnectWithoutUserInput
    connect?: UserStatsWhereUniqueInput
  }

  export type IntegrationCanvasCreateNestedOneWithoutUserInput = {
    create?: XOR<IntegrationCanvasCreateWithoutUserInput, IntegrationCanvasUncheckedCreateWithoutUserInput>
    connectOrCreate?: IntegrationCanvasCreateOrConnectWithoutUserInput
    connect?: IntegrationCanvasWhereUniqueInput
  }

  export type WeeklyClassCreateNestedManyWithoutUserInput = {
    create?: XOR<WeeklyClassCreateWithoutUserInput, WeeklyClassUncheckedCreateWithoutUserInput> | WeeklyClassCreateWithoutUserInput[] | WeeklyClassUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WeeklyClassCreateOrConnectWithoutUserInput | WeeklyClassCreateOrConnectWithoutUserInput[]
    createMany?: WeeklyClassCreateManyUserInputEnvelope
    connect?: WeeklyClassWhereUniqueInput | WeeklyClassWhereUniqueInput[]
  }

  export type FixedEventCreateNestedManyWithoutUserInput = {
    create?: XOR<FixedEventCreateWithoutUserInput, FixedEventUncheckedCreateWithoutUserInput> | FixedEventCreateWithoutUserInput[] | FixedEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FixedEventCreateOrConnectWithoutUserInput | FixedEventCreateOrConnectWithoutUserInput[]
    createMany?: FixedEventCreateManyUserInputEnvelope
    connect?: FixedEventWhereUniqueInput | FixedEventWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput> | TaskCreateWithoutUserInput[] | TaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUserInput | TaskCreateOrConnectWithoutUserInput[]
    createMany?: TaskCreateManyUserInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type StudyBlockUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StudyBlockCreateWithoutUserInput, StudyBlockUncheckedCreateWithoutUserInput> | StudyBlockCreateWithoutUserInput[] | StudyBlockUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudyBlockCreateOrConnectWithoutUserInput | StudyBlockCreateOrConnectWithoutUserInput[]
    createMany?: StudyBlockCreateManyUserInputEnvelope
    connect?: StudyBlockWhereUniqueInput | StudyBlockWhereUniqueInput[]
  }

  export type StudySessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StudySessionCreateWithoutUserInput, StudySessionUncheckedCreateWithoutUserInput> | StudySessionCreateWithoutUserInput[] | StudySessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudySessionCreateOrConnectWithoutUserInput | StudySessionCreateOrConnectWithoutUserInput[]
    createMany?: StudySessionCreateManyUserInputEnvelope
    connect?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
  }

  export type RewardUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RewardCreateWithoutUserInput, RewardUncheckedCreateWithoutUserInput> | RewardCreateWithoutUserInput[] | RewardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RewardCreateOrConnectWithoutUserInput | RewardCreateOrConnectWithoutUserInput[]
    createMany?: RewardCreateManyUserInputEnvelope
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
  }

  export type UserStatsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserStatsCreateWithoutUserInput, UserStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserStatsCreateOrConnectWithoutUserInput
    connect?: UserStatsWhereUniqueInput
  }

  export type IntegrationCanvasUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<IntegrationCanvasCreateWithoutUserInput, IntegrationCanvasUncheckedCreateWithoutUserInput>
    connectOrCreate?: IntegrationCanvasCreateOrConnectWithoutUserInput
    connect?: IntegrationCanvasWhereUniqueInput
  }

  export type WeeklyClassUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WeeklyClassCreateWithoutUserInput, WeeklyClassUncheckedCreateWithoutUserInput> | WeeklyClassCreateWithoutUserInput[] | WeeklyClassUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WeeklyClassCreateOrConnectWithoutUserInput | WeeklyClassCreateOrConnectWithoutUserInput[]
    createMany?: WeeklyClassCreateManyUserInputEnvelope
    connect?: WeeklyClassWhereUniqueInput | WeeklyClassWhereUniqueInput[]
  }

  export type FixedEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FixedEventCreateWithoutUserInput, FixedEventUncheckedCreateWithoutUserInput> | FixedEventCreateWithoutUserInput[] | FixedEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FixedEventCreateOrConnectWithoutUserInput | FixedEventCreateOrConnectWithoutUserInput[]
    createMany?: FixedEventCreateManyUserInputEnvelope
    connect?: FixedEventWhereUniqueInput | FixedEventWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TaskUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput> | TaskCreateWithoutUserInput[] | TaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUserInput | TaskCreateOrConnectWithoutUserInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutUserInput | TaskUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskCreateManyUserInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutUserInput | TaskUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutUserInput | TaskUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type StudyBlockUpdateManyWithoutUserNestedInput = {
    create?: XOR<StudyBlockCreateWithoutUserInput, StudyBlockUncheckedCreateWithoutUserInput> | StudyBlockCreateWithoutUserInput[] | StudyBlockUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudyBlockCreateOrConnectWithoutUserInput | StudyBlockCreateOrConnectWithoutUserInput[]
    upsert?: StudyBlockUpsertWithWhereUniqueWithoutUserInput | StudyBlockUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StudyBlockCreateManyUserInputEnvelope
    set?: StudyBlockWhereUniqueInput | StudyBlockWhereUniqueInput[]
    disconnect?: StudyBlockWhereUniqueInput | StudyBlockWhereUniqueInput[]
    delete?: StudyBlockWhereUniqueInput | StudyBlockWhereUniqueInput[]
    connect?: StudyBlockWhereUniqueInput | StudyBlockWhereUniqueInput[]
    update?: StudyBlockUpdateWithWhereUniqueWithoutUserInput | StudyBlockUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StudyBlockUpdateManyWithWhereWithoutUserInput | StudyBlockUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StudyBlockScalarWhereInput | StudyBlockScalarWhereInput[]
  }

  export type StudySessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<StudySessionCreateWithoutUserInput, StudySessionUncheckedCreateWithoutUserInput> | StudySessionCreateWithoutUserInput[] | StudySessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudySessionCreateOrConnectWithoutUserInput | StudySessionCreateOrConnectWithoutUserInput[]
    upsert?: StudySessionUpsertWithWhereUniqueWithoutUserInput | StudySessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StudySessionCreateManyUserInputEnvelope
    set?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    disconnect?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    delete?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    connect?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    update?: StudySessionUpdateWithWhereUniqueWithoutUserInput | StudySessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StudySessionUpdateManyWithWhereWithoutUserInput | StudySessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StudySessionScalarWhereInput | StudySessionScalarWhereInput[]
  }

  export type RewardUpdateManyWithoutUserNestedInput = {
    create?: XOR<RewardCreateWithoutUserInput, RewardUncheckedCreateWithoutUserInput> | RewardCreateWithoutUserInput[] | RewardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RewardCreateOrConnectWithoutUserInput | RewardCreateOrConnectWithoutUserInput[]
    upsert?: RewardUpsertWithWhereUniqueWithoutUserInput | RewardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RewardCreateManyUserInputEnvelope
    set?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    disconnect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    delete?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    update?: RewardUpdateWithWhereUniqueWithoutUserInput | RewardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RewardUpdateManyWithWhereWithoutUserInput | RewardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RewardScalarWhereInput | RewardScalarWhereInput[]
  }

  export type UserStatsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserStatsCreateWithoutUserInput, UserStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserStatsCreateOrConnectWithoutUserInput
    upsert?: UserStatsUpsertWithoutUserInput
    disconnect?: UserStatsWhereInput | boolean
    delete?: UserStatsWhereInput | boolean
    connect?: UserStatsWhereUniqueInput
    update?: XOR<XOR<UserStatsUpdateToOneWithWhereWithoutUserInput, UserStatsUpdateWithoutUserInput>, UserStatsUncheckedUpdateWithoutUserInput>
  }

  export type IntegrationCanvasUpdateOneWithoutUserNestedInput = {
    create?: XOR<IntegrationCanvasCreateWithoutUserInput, IntegrationCanvasUncheckedCreateWithoutUserInput>
    connectOrCreate?: IntegrationCanvasCreateOrConnectWithoutUserInput
    upsert?: IntegrationCanvasUpsertWithoutUserInput
    disconnect?: IntegrationCanvasWhereInput | boolean
    delete?: IntegrationCanvasWhereInput | boolean
    connect?: IntegrationCanvasWhereUniqueInput
    update?: XOR<XOR<IntegrationCanvasUpdateToOneWithWhereWithoutUserInput, IntegrationCanvasUpdateWithoutUserInput>, IntegrationCanvasUncheckedUpdateWithoutUserInput>
  }

  export type WeeklyClassUpdateManyWithoutUserNestedInput = {
    create?: XOR<WeeklyClassCreateWithoutUserInput, WeeklyClassUncheckedCreateWithoutUserInput> | WeeklyClassCreateWithoutUserInput[] | WeeklyClassUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WeeklyClassCreateOrConnectWithoutUserInput | WeeklyClassCreateOrConnectWithoutUserInput[]
    upsert?: WeeklyClassUpsertWithWhereUniqueWithoutUserInput | WeeklyClassUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WeeklyClassCreateManyUserInputEnvelope
    set?: WeeklyClassWhereUniqueInput | WeeklyClassWhereUniqueInput[]
    disconnect?: WeeklyClassWhereUniqueInput | WeeklyClassWhereUniqueInput[]
    delete?: WeeklyClassWhereUniqueInput | WeeklyClassWhereUniqueInput[]
    connect?: WeeklyClassWhereUniqueInput | WeeklyClassWhereUniqueInput[]
    update?: WeeklyClassUpdateWithWhereUniqueWithoutUserInput | WeeklyClassUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WeeklyClassUpdateManyWithWhereWithoutUserInput | WeeklyClassUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WeeklyClassScalarWhereInput | WeeklyClassScalarWhereInput[]
  }

  export type FixedEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<FixedEventCreateWithoutUserInput, FixedEventUncheckedCreateWithoutUserInput> | FixedEventCreateWithoutUserInput[] | FixedEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FixedEventCreateOrConnectWithoutUserInput | FixedEventCreateOrConnectWithoutUserInput[]
    upsert?: FixedEventUpsertWithWhereUniqueWithoutUserInput | FixedEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FixedEventCreateManyUserInputEnvelope
    set?: FixedEventWhereUniqueInput | FixedEventWhereUniqueInput[]
    disconnect?: FixedEventWhereUniqueInput | FixedEventWhereUniqueInput[]
    delete?: FixedEventWhereUniqueInput | FixedEventWhereUniqueInput[]
    connect?: FixedEventWhereUniqueInput | FixedEventWhereUniqueInput[]
    update?: FixedEventUpdateWithWhereUniqueWithoutUserInput | FixedEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FixedEventUpdateManyWithWhereWithoutUserInput | FixedEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FixedEventScalarWhereInput | FixedEventScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput> | TaskCreateWithoutUserInput[] | TaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUserInput | TaskCreateOrConnectWithoutUserInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutUserInput | TaskUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskCreateManyUserInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutUserInput | TaskUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutUserInput | TaskUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type StudyBlockUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StudyBlockCreateWithoutUserInput, StudyBlockUncheckedCreateWithoutUserInput> | StudyBlockCreateWithoutUserInput[] | StudyBlockUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudyBlockCreateOrConnectWithoutUserInput | StudyBlockCreateOrConnectWithoutUserInput[]
    upsert?: StudyBlockUpsertWithWhereUniqueWithoutUserInput | StudyBlockUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StudyBlockCreateManyUserInputEnvelope
    set?: StudyBlockWhereUniqueInput | StudyBlockWhereUniqueInput[]
    disconnect?: StudyBlockWhereUniqueInput | StudyBlockWhereUniqueInput[]
    delete?: StudyBlockWhereUniqueInput | StudyBlockWhereUniqueInput[]
    connect?: StudyBlockWhereUniqueInput | StudyBlockWhereUniqueInput[]
    update?: StudyBlockUpdateWithWhereUniqueWithoutUserInput | StudyBlockUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StudyBlockUpdateManyWithWhereWithoutUserInput | StudyBlockUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StudyBlockScalarWhereInput | StudyBlockScalarWhereInput[]
  }

  export type StudySessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StudySessionCreateWithoutUserInput, StudySessionUncheckedCreateWithoutUserInput> | StudySessionCreateWithoutUserInput[] | StudySessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudySessionCreateOrConnectWithoutUserInput | StudySessionCreateOrConnectWithoutUserInput[]
    upsert?: StudySessionUpsertWithWhereUniqueWithoutUserInput | StudySessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StudySessionCreateManyUserInputEnvelope
    set?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    disconnect?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    delete?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    connect?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    update?: StudySessionUpdateWithWhereUniqueWithoutUserInput | StudySessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StudySessionUpdateManyWithWhereWithoutUserInput | StudySessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StudySessionScalarWhereInput | StudySessionScalarWhereInput[]
  }

  export type RewardUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RewardCreateWithoutUserInput, RewardUncheckedCreateWithoutUserInput> | RewardCreateWithoutUserInput[] | RewardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RewardCreateOrConnectWithoutUserInput | RewardCreateOrConnectWithoutUserInput[]
    upsert?: RewardUpsertWithWhereUniqueWithoutUserInput | RewardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RewardCreateManyUserInputEnvelope
    set?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    disconnect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    delete?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    connect?: RewardWhereUniqueInput | RewardWhereUniqueInput[]
    update?: RewardUpdateWithWhereUniqueWithoutUserInput | RewardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RewardUpdateManyWithWhereWithoutUserInput | RewardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RewardScalarWhereInput | RewardScalarWhereInput[]
  }

  export type UserStatsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserStatsCreateWithoutUserInput, UserStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserStatsCreateOrConnectWithoutUserInput
    upsert?: UserStatsUpsertWithoutUserInput
    disconnect?: UserStatsWhereInput | boolean
    delete?: UserStatsWhereInput | boolean
    connect?: UserStatsWhereUniqueInput
    update?: XOR<XOR<UserStatsUpdateToOneWithWhereWithoutUserInput, UserStatsUpdateWithoutUserInput>, UserStatsUncheckedUpdateWithoutUserInput>
  }

  export type IntegrationCanvasUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<IntegrationCanvasCreateWithoutUserInput, IntegrationCanvasUncheckedCreateWithoutUserInput>
    connectOrCreate?: IntegrationCanvasCreateOrConnectWithoutUserInput
    upsert?: IntegrationCanvasUpsertWithoutUserInput
    disconnect?: IntegrationCanvasWhereInput | boolean
    delete?: IntegrationCanvasWhereInput | boolean
    connect?: IntegrationCanvasWhereUniqueInput
    update?: XOR<XOR<IntegrationCanvasUpdateToOneWithWhereWithoutUserInput, IntegrationCanvasUpdateWithoutUserInput>, IntegrationCanvasUncheckedUpdateWithoutUserInput>
  }

  export type WeeklyClassUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WeeklyClassCreateWithoutUserInput, WeeklyClassUncheckedCreateWithoutUserInput> | WeeklyClassCreateWithoutUserInput[] | WeeklyClassUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WeeklyClassCreateOrConnectWithoutUserInput | WeeklyClassCreateOrConnectWithoutUserInput[]
    upsert?: WeeklyClassUpsertWithWhereUniqueWithoutUserInput | WeeklyClassUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WeeklyClassCreateManyUserInputEnvelope
    set?: WeeklyClassWhereUniqueInput | WeeklyClassWhereUniqueInput[]
    disconnect?: WeeklyClassWhereUniqueInput | WeeklyClassWhereUniqueInput[]
    delete?: WeeklyClassWhereUniqueInput | WeeklyClassWhereUniqueInput[]
    connect?: WeeklyClassWhereUniqueInput | WeeklyClassWhereUniqueInput[]
    update?: WeeklyClassUpdateWithWhereUniqueWithoutUserInput | WeeklyClassUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WeeklyClassUpdateManyWithWhereWithoutUserInput | WeeklyClassUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WeeklyClassScalarWhereInput | WeeklyClassScalarWhereInput[]
  }

  export type FixedEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FixedEventCreateWithoutUserInput, FixedEventUncheckedCreateWithoutUserInput> | FixedEventCreateWithoutUserInput[] | FixedEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FixedEventCreateOrConnectWithoutUserInput | FixedEventCreateOrConnectWithoutUserInput[]
    upsert?: FixedEventUpsertWithWhereUniqueWithoutUserInput | FixedEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FixedEventCreateManyUserInputEnvelope
    set?: FixedEventWhereUniqueInput | FixedEventWhereUniqueInput[]
    disconnect?: FixedEventWhereUniqueInput | FixedEventWhereUniqueInput[]
    delete?: FixedEventWhereUniqueInput | FixedEventWhereUniqueInput[]
    connect?: FixedEventWhereUniqueInput | FixedEventWhereUniqueInput[]
    update?: FixedEventUpdateWithWhereUniqueWithoutUserInput | FixedEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FixedEventUpdateManyWithWhereWithoutUserInput | FixedEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FixedEventScalarWhereInput | FixedEventScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTasksInput = {
    create?: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksInput
    connect?: UserWhereUniqueInput
  }

  export type StudyBlockCreateNestedManyWithoutTaskInput = {
    create?: XOR<StudyBlockCreateWithoutTaskInput, StudyBlockUncheckedCreateWithoutTaskInput> | StudyBlockCreateWithoutTaskInput[] | StudyBlockUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: StudyBlockCreateOrConnectWithoutTaskInput | StudyBlockCreateOrConnectWithoutTaskInput[]
    createMany?: StudyBlockCreateManyTaskInputEnvelope
    connect?: StudyBlockWhereUniqueInput | StudyBlockWhereUniqueInput[]
  }

  export type StudySessionCreateNestedManyWithoutTaskInput = {
    create?: XOR<StudySessionCreateWithoutTaskInput, StudySessionUncheckedCreateWithoutTaskInput> | StudySessionCreateWithoutTaskInput[] | StudySessionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: StudySessionCreateOrConnectWithoutTaskInput | StudySessionCreateOrConnectWithoutTaskInput[]
    createMany?: StudySessionCreateManyTaskInputEnvelope
    connect?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
  }

  export type StudyBlockUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<StudyBlockCreateWithoutTaskInput, StudyBlockUncheckedCreateWithoutTaskInput> | StudyBlockCreateWithoutTaskInput[] | StudyBlockUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: StudyBlockCreateOrConnectWithoutTaskInput | StudyBlockCreateOrConnectWithoutTaskInput[]
    createMany?: StudyBlockCreateManyTaskInputEnvelope
    connect?: StudyBlockWhereUniqueInput | StudyBlockWhereUniqueInput[]
  }

  export type StudySessionUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<StudySessionCreateWithoutTaskInput, StudySessionUncheckedCreateWithoutTaskInput> | StudySessionCreateWithoutTaskInput[] | StudySessionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: StudySessionCreateOrConnectWithoutTaskInput | StudySessionCreateOrConnectWithoutTaskInput[]
    createMany?: StudySessionCreateManyTaskInputEnvelope
    connect?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksInput
    upsert?: UserUpsertWithoutTasksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTasksInput, UserUpdateWithoutTasksInput>, UserUncheckedUpdateWithoutTasksInput>
  }

  export type StudyBlockUpdateManyWithoutTaskNestedInput = {
    create?: XOR<StudyBlockCreateWithoutTaskInput, StudyBlockUncheckedCreateWithoutTaskInput> | StudyBlockCreateWithoutTaskInput[] | StudyBlockUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: StudyBlockCreateOrConnectWithoutTaskInput | StudyBlockCreateOrConnectWithoutTaskInput[]
    upsert?: StudyBlockUpsertWithWhereUniqueWithoutTaskInput | StudyBlockUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: StudyBlockCreateManyTaskInputEnvelope
    set?: StudyBlockWhereUniqueInput | StudyBlockWhereUniqueInput[]
    disconnect?: StudyBlockWhereUniqueInput | StudyBlockWhereUniqueInput[]
    delete?: StudyBlockWhereUniqueInput | StudyBlockWhereUniqueInput[]
    connect?: StudyBlockWhereUniqueInput | StudyBlockWhereUniqueInput[]
    update?: StudyBlockUpdateWithWhereUniqueWithoutTaskInput | StudyBlockUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: StudyBlockUpdateManyWithWhereWithoutTaskInput | StudyBlockUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: StudyBlockScalarWhereInput | StudyBlockScalarWhereInput[]
  }

  export type StudySessionUpdateManyWithoutTaskNestedInput = {
    create?: XOR<StudySessionCreateWithoutTaskInput, StudySessionUncheckedCreateWithoutTaskInput> | StudySessionCreateWithoutTaskInput[] | StudySessionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: StudySessionCreateOrConnectWithoutTaskInput | StudySessionCreateOrConnectWithoutTaskInput[]
    upsert?: StudySessionUpsertWithWhereUniqueWithoutTaskInput | StudySessionUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: StudySessionCreateManyTaskInputEnvelope
    set?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    disconnect?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    delete?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    connect?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    update?: StudySessionUpdateWithWhereUniqueWithoutTaskInput | StudySessionUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: StudySessionUpdateManyWithWhereWithoutTaskInput | StudySessionUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: StudySessionScalarWhereInput | StudySessionScalarWhereInput[]
  }

  export type StudyBlockUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<StudyBlockCreateWithoutTaskInput, StudyBlockUncheckedCreateWithoutTaskInput> | StudyBlockCreateWithoutTaskInput[] | StudyBlockUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: StudyBlockCreateOrConnectWithoutTaskInput | StudyBlockCreateOrConnectWithoutTaskInput[]
    upsert?: StudyBlockUpsertWithWhereUniqueWithoutTaskInput | StudyBlockUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: StudyBlockCreateManyTaskInputEnvelope
    set?: StudyBlockWhereUniqueInput | StudyBlockWhereUniqueInput[]
    disconnect?: StudyBlockWhereUniqueInput | StudyBlockWhereUniqueInput[]
    delete?: StudyBlockWhereUniqueInput | StudyBlockWhereUniqueInput[]
    connect?: StudyBlockWhereUniqueInput | StudyBlockWhereUniqueInput[]
    update?: StudyBlockUpdateWithWhereUniqueWithoutTaskInput | StudyBlockUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: StudyBlockUpdateManyWithWhereWithoutTaskInput | StudyBlockUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: StudyBlockScalarWhereInput | StudyBlockScalarWhereInput[]
  }

  export type StudySessionUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<StudySessionCreateWithoutTaskInput, StudySessionUncheckedCreateWithoutTaskInput> | StudySessionCreateWithoutTaskInput[] | StudySessionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: StudySessionCreateOrConnectWithoutTaskInput | StudySessionCreateOrConnectWithoutTaskInput[]
    upsert?: StudySessionUpsertWithWhereUniqueWithoutTaskInput | StudySessionUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: StudySessionCreateManyTaskInputEnvelope
    set?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    disconnect?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    delete?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    connect?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    update?: StudySessionUpdateWithWhereUniqueWithoutTaskInput | StudySessionUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: StudySessionUpdateManyWithWhereWithoutTaskInput | StudySessionUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: StudySessionScalarWhereInput | StudySessionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutStudyBlocksInput = {
    create?: XOR<UserCreateWithoutStudyBlocksInput, UserUncheckedCreateWithoutStudyBlocksInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudyBlocksInput
    connect?: UserWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutStudyBlocksInput = {
    create?: XOR<TaskCreateWithoutStudyBlocksInput, TaskUncheckedCreateWithoutStudyBlocksInput>
    connectOrCreate?: TaskCreateOrConnectWithoutStudyBlocksInput
    connect?: TaskWhereUniqueInput
  }

  export type StudySessionCreateNestedOneWithoutBlockInput = {
    create?: XOR<StudySessionCreateWithoutBlockInput, StudySessionUncheckedCreateWithoutBlockInput>
    connectOrCreate?: StudySessionCreateOrConnectWithoutBlockInput
    connect?: StudySessionWhereUniqueInput
  }

  export type StudySessionUncheckedCreateNestedOneWithoutBlockInput = {
    create?: XOR<StudySessionCreateWithoutBlockInput, StudySessionUncheckedCreateWithoutBlockInput>
    connectOrCreate?: StudySessionCreateOrConnectWithoutBlockInput
    connect?: StudySessionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutStudyBlocksNestedInput = {
    create?: XOR<UserCreateWithoutStudyBlocksInput, UserUncheckedCreateWithoutStudyBlocksInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudyBlocksInput
    upsert?: UserUpsertWithoutStudyBlocksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudyBlocksInput, UserUpdateWithoutStudyBlocksInput>, UserUncheckedUpdateWithoutStudyBlocksInput>
  }

  export type TaskUpdateOneWithoutStudyBlocksNestedInput = {
    create?: XOR<TaskCreateWithoutStudyBlocksInput, TaskUncheckedCreateWithoutStudyBlocksInput>
    connectOrCreate?: TaskCreateOrConnectWithoutStudyBlocksInput
    upsert?: TaskUpsertWithoutStudyBlocksInput
    disconnect?: TaskWhereInput | boolean
    delete?: TaskWhereInput | boolean
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutStudyBlocksInput, TaskUpdateWithoutStudyBlocksInput>, TaskUncheckedUpdateWithoutStudyBlocksInput>
  }

  export type StudySessionUpdateOneWithoutBlockNestedInput = {
    create?: XOR<StudySessionCreateWithoutBlockInput, StudySessionUncheckedCreateWithoutBlockInput>
    connectOrCreate?: StudySessionCreateOrConnectWithoutBlockInput
    upsert?: StudySessionUpsertWithoutBlockInput
    disconnect?: StudySessionWhereInput | boolean
    delete?: StudySessionWhereInput | boolean
    connect?: StudySessionWhereUniqueInput
    update?: XOR<XOR<StudySessionUpdateToOneWithWhereWithoutBlockInput, StudySessionUpdateWithoutBlockInput>, StudySessionUncheckedUpdateWithoutBlockInput>
  }

  export type StudySessionUncheckedUpdateOneWithoutBlockNestedInput = {
    create?: XOR<StudySessionCreateWithoutBlockInput, StudySessionUncheckedCreateWithoutBlockInput>
    connectOrCreate?: StudySessionCreateOrConnectWithoutBlockInput
    upsert?: StudySessionUpsertWithoutBlockInput
    disconnect?: StudySessionWhereInput | boolean
    delete?: StudySessionWhereInput | boolean
    connect?: StudySessionWhereUniqueInput
    update?: XOR<XOR<StudySessionUpdateToOneWithWhereWithoutBlockInput, StudySessionUpdateWithoutBlockInput>, StudySessionUncheckedUpdateWithoutBlockInput>
  }

  export type UserCreateNestedOneWithoutStudySessionsInput = {
    create?: XOR<UserCreateWithoutStudySessionsInput, UserUncheckedCreateWithoutStudySessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudySessionsInput
    connect?: UserWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutStudySessionsInput = {
    create?: XOR<TaskCreateWithoutStudySessionsInput, TaskUncheckedCreateWithoutStudySessionsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutStudySessionsInput
    connect?: TaskWhereUniqueInput
  }

  export type StudyBlockCreateNestedOneWithoutStudySessionInput = {
    create?: XOR<StudyBlockCreateWithoutStudySessionInput, StudyBlockUncheckedCreateWithoutStudySessionInput>
    connectOrCreate?: StudyBlockCreateOrConnectWithoutStudySessionInput
    connect?: StudyBlockWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutStudySessionsNestedInput = {
    create?: XOR<UserCreateWithoutStudySessionsInput, UserUncheckedCreateWithoutStudySessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudySessionsInput
    upsert?: UserUpsertWithoutStudySessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudySessionsInput, UserUpdateWithoutStudySessionsInput>, UserUncheckedUpdateWithoutStudySessionsInput>
  }

  export type TaskUpdateOneWithoutStudySessionsNestedInput = {
    create?: XOR<TaskCreateWithoutStudySessionsInput, TaskUncheckedCreateWithoutStudySessionsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutStudySessionsInput
    upsert?: TaskUpsertWithoutStudySessionsInput
    disconnect?: TaskWhereInput | boolean
    delete?: TaskWhereInput | boolean
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutStudySessionsInput, TaskUpdateWithoutStudySessionsInput>, TaskUncheckedUpdateWithoutStudySessionsInput>
  }

  export type StudyBlockUpdateOneWithoutStudySessionNestedInput = {
    create?: XOR<StudyBlockCreateWithoutStudySessionInput, StudyBlockUncheckedCreateWithoutStudySessionInput>
    connectOrCreate?: StudyBlockCreateOrConnectWithoutStudySessionInput
    upsert?: StudyBlockUpsertWithoutStudySessionInput
    disconnect?: StudyBlockWhereInput | boolean
    delete?: StudyBlockWhereInput | boolean
    connect?: StudyBlockWhereUniqueInput
    update?: XOR<XOR<StudyBlockUpdateToOneWithWhereWithoutStudySessionInput, StudyBlockUpdateWithoutStudySessionInput>, StudyBlockUncheckedUpdateWithoutStudySessionInput>
  }

  export type UserCreateNestedOneWithoutRewardsInput = {
    create?: XOR<UserCreateWithoutRewardsInput, UserUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRewardsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRewardsNestedInput = {
    create?: XOR<UserCreateWithoutRewardsInput, UserUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRewardsInput
    upsert?: UserUpsertWithoutRewardsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRewardsInput, UserUpdateWithoutRewardsInput>, UserUncheckedUpdateWithoutRewardsInput>
  }

  export type UserCreateNestedOneWithoutStatsInput = {
    create?: XOR<UserCreateWithoutStatsInput, UserUncheckedCreateWithoutStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStatsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutStatsNestedInput = {
    create?: XOR<UserCreateWithoutStatsInput, UserUncheckedCreateWithoutStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStatsInput
    upsert?: UserUpsertWithoutStatsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStatsInput, UserUpdateWithoutStatsInput>, UserUncheckedUpdateWithoutStatsInput>
  }

  export type UserCreateNestedOneWithoutIntegrationCanvasInput = {
    create?: XOR<UserCreateWithoutIntegrationCanvasInput, UserUncheckedCreateWithoutIntegrationCanvasInput>
    connectOrCreate?: UserCreateOrConnectWithoutIntegrationCanvasInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutIntegrationCanvasNestedInput = {
    create?: XOR<UserCreateWithoutIntegrationCanvasInput, UserUncheckedCreateWithoutIntegrationCanvasInput>
    connectOrCreate?: UserCreateOrConnectWithoutIntegrationCanvasInput
    upsert?: UserUpsertWithoutIntegrationCanvasInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIntegrationCanvasInput, UserUpdateWithoutIntegrationCanvasInput>, UserUncheckedUpdateWithoutIntegrationCanvasInput>
  }

  export type UserCreateNestedOneWithoutFixedEventsInput = {
    create?: XOR<UserCreateWithoutFixedEventsInput, UserUncheckedCreateWithoutFixedEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFixedEventsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFixedEventsNestedInput = {
    create?: XOR<UserCreateWithoutFixedEventsInput, UserUncheckedCreateWithoutFixedEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFixedEventsInput
    upsert?: UserUpsertWithoutFixedEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFixedEventsInput, UserUpdateWithoutFixedEventsInput>, UserUncheckedUpdateWithoutFixedEventsInput>
  }

  export type UserCreateNestedOneWithoutWeeklyClassesInput = {
    create?: XOR<UserCreateWithoutWeeklyClassesInput, UserUncheckedCreateWithoutWeeklyClassesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWeeklyClassesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWeeklyClassesNestedInput = {
    create?: XOR<UserCreateWithoutWeeklyClassesInput, UserUncheckedCreateWithoutWeeklyClassesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWeeklyClassesInput
    upsert?: UserUpsertWithoutWeeklyClassesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWeeklyClassesInput, UserUpdateWithoutWeeklyClassesInput>, UserUncheckedUpdateWithoutWeeklyClassesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type TaskCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    deadline?: Date | string | null
    difficulty?: string
    priority?: number
    remainingHours?: number
    status?: string
    source?: string
    externalId?: string | null
    completedAt?: Date | string | null
    completionXpAwarded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studyBlocks?: StudyBlockCreateNestedManyWithoutTaskInput
    studySessions?: StudySessionCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    deadline?: Date | string | null
    difficulty?: string
    priority?: number
    remainingHours?: number
    status?: string
    source?: string
    externalId?: string | null
    completedAt?: Date | string | null
    completionXpAwarded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studyBlocks?: StudyBlockUncheckedCreateNestedManyWithoutTaskInput
    studySessions?: StudySessionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutUserInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput>
  }

  export type TaskCreateManyUserInputEnvelope = {
    data: TaskCreateManyUserInput | TaskCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StudyBlockCreateWithoutUserInput = {
    id?: string
    start: Date | string
    end: Date | string
    source?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    task?: TaskCreateNestedOneWithoutStudyBlocksInput
    studySession?: StudySessionCreateNestedOneWithoutBlockInput
  }

  export type StudyBlockUncheckedCreateWithoutUserInput = {
    id?: string
    taskId?: string | null
    start: Date | string
    end: Date | string
    source?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studySession?: StudySessionUncheckedCreateNestedOneWithoutBlockInput
  }

  export type StudyBlockCreateOrConnectWithoutUserInput = {
    where: StudyBlockWhereUniqueInput
    create: XOR<StudyBlockCreateWithoutUserInput, StudyBlockUncheckedCreateWithoutUserInput>
  }

  export type StudyBlockCreateManyUserInputEnvelope = {
    data: StudyBlockCreateManyUserInput | StudyBlockCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StudySessionCreateWithoutUserInput = {
    id?: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: string
    focusedMinutes?: number
    xpEarned?: number
    task?: TaskCreateNestedOneWithoutStudySessionsInput
    block?: StudyBlockCreateNestedOneWithoutStudySessionInput
  }

  export type StudySessionUncheckedCreateWithoutUserInput = {
    id?: string
    taskId?: string | null
    blockId?: string | null
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: string
    focusedMinutes?: number
    xpEarned?: number
  }

  export type StudySessionCreateOrConnectWithoutUserInput = {
    where: StudySessionWhereUniqueInput
    create: XOR<StudySessionCreateWithoutUserInput, StudySessionUncheckedCreateWithoutUserInput>
  }

  export type StudySessionCreateManyUserInputEnvelope = {
    data: StudySessionCreateManyUserInput | StudySessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RewardCreateWithoutUserInput = {
    id?: string
    label: string
    detail?: string | null
    costXp?: number
    claimedAt?: Date | string | null
  }

  export type RewardUncheckedCreateWithoutUserInput = {
    id?: string
    label: string
    detail?: string | null
    costXp?: number
    claimedAt?: Date | string | null
  }

  export type RewardCreateOrConnectWithoutUserInput = {
    where: RewardWhereUniqueInput
    create: XOR<RewardCreateWithoutUserInput, RewardUncheckedCreateWithoutUserInput>
  }

  export type RewardCreateManyUserInputEnvelope = {
    data: RewardCreateManyUserInput | RewardCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserStatsCreateWithoutUserInput = {
    id?: string
    totalXp?: number
    weeklyXp?: number
    streak?: number
    level?: number
    dailyBaseXp?: number
    dailyXp?: number
    dailyDate?: Date | string | null
    lastSessionAt?: Date | string | null
  }

  export type UserStatsUncheckedCreateWithoutUserInput = {
    id?: string
    totalXp?: number
    weeklyXp?: number
    streak?: number
    level?: number
    dailyBaseXp?: number
    dailyXp?: number
    dailyDate?: Date | string | null
    lastSessionAt?: Date | string | null
  }

  export type UserStatsCreateOrConnectWithoutUserInput = {
    where: UserStatsWhereUniqueInput
    create: XOR<UserStatsCreateWithoutUserInput, UserStatsUncheckedCreateWithoutUserInput>
  }

  export type IntegrationCanvasCreateWithoutUserInput = {
    id?: string
    tokenEncrypted?: string | null
    canvasBaseUrl: string
    canvasUserId?: string | null
    lastImportedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationCanvasUncheckedCreateWithoutUserInput = {
    id?: string
    tokenEncrypted?: string | null
    canvasBaseUrl: string
    canvasUserId?: string | null
    lastImportedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationCanvasCreateOrConnectWithoutUserInput = {
    where: IntegrationCanvasWhereUniqueInput
    create: XOR<IntegrationCanvasCreateWithoutUserInput, IntegrationCanvasUncheckedCreateWithoutUserInput>
  }

  export type WeeklyClassCreateWithoutUserInput = {
    id?: string
    title: string
    day: number
    start: string
    end: string
    location?: string | null
    source?: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeeklyClassUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    day: number
    start: string
    end: string
    location?: string | null
    source?: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeeklyClassCreateOrConnectWithoutUserInput = {
    where: WeeklyClassWhereUniqueInput
    create: XOR<WeeklyClassCreateWithoutUserInput, WeeklyClassUncheckedCreateWithoutUserInput>
  }

  export type WeeklyClassCreateManyUserInputEnvelope = {
    data: WeeklyClassCreateManyUserInput | WeeklyClassCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FixedEventCreateWithoutUserInput = {
    id?: string
    title: string
    type?: string
    start: Date | string
    end: Date | string
    notes?: string | null
    source?: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FixedEventUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    type?: string
    start: Date | string
    end: Date | string
    notes?: string | null
    source?: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FixedEventCreateOrConnectWithoutUserInput = {
    where: FixedEventWhereUniqueInput
    create: XOR<FixedEventCreateWithoutUserInput, FixedEventUncheckedCreateWithoutUserInput>
  }

  export type FixedEventCreateManyUserInputEnvelope = {
    data: FixedEventCreateManyUserInput | FixedEventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TaskUpsertWithWhereUniqueWithoutUserInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutUserInput, TaskUncheckedUpdateWithoutUserInput>
    create: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutUserInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutUserInput, TaskUncheckedUpdateWithoutUserInput>
  }

  export type TaskUpdateManyWithWhereWithoutUserInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutUserInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    userId?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    deadline?: DateTimeNullableFilter<"Task"> | Date | string | null
    difficulty?: StringFilter<"Task"> | string
    priority?: IntFilter<"Task"> | number
    remainingHours?: IntFilter<"Task"> | number
    status?: StringFilter<"Task"> | string
    source?: StringFilter<"Task"> | string
    externalId?: StringNullableFilter<"Task"> | string | null
    completedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    completionXpAwarded?: BoolFilter<"Task"> | boolean
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
  }

  export type StudyBlockUpsertWithWhereUniqueWithoutUserInput = {
    where: StudyBlockWhereUniqueInput
    update: XOR<StudyBlockUpdateWithoutUserInput, StudyBlockUncheckedUpdateWithoutUserInput>
    create: XOR<StudyBlockCreateWithoutUserInput, StudyBlockUncheckedCreateWithoutUserInput>
  }

  export type StudyBlockUpdateWithWhereUniqueWithoutUserInput = {
    where: StudyBlockWhereUniqueInput
    data: XOR<StudyBlockUpdateWithoutUserInput, StudyBlockUncheckedUpdateWithoutUserInput>
  }

  export type StudyBlockUpdateManyWithWhereWithoutUserInput = {
    where: StudyBlockScalarWhereInput
    data: XOR<StudyBlockUpdateManyMutationInput, StudyBlockUncheckedUpdateManyWithoutUserInput>
  }

  export type StudyBlockScalarWhereInput = {
    AND?: StudyBlockScalarWhereInput | StudyBlockScalarWhereInput[]
    OR?: StudyBlockScalarWhereInput[]
    NOT?: StudyBlockScalarWhereInput | StudyBlockScalarWhereInput[]
    id?: StringFilter<"StudyBlock"> | string
    userId?: StringFilter<"StudyBlock"> | string
    taskId?: StringNullableFilter<"StudyBlock"> | string | null
    start?: DateTimeFilter<"StudyBlock"> | Date | string
    end?: DateTimeFilter<"StudyBlock"> | Date | string
    source?: StringFilter<"StudyBlock"> | string
    status?: StringFilter<"StudyBlock"> | string
    createdAt?: DateTimeFilter<"StudyBlock"> | Date | string
    updatedAt?: DateTimeFilter<"StudyBlock"> | Date | string
  }

  export type StudySessionUpsertWithWhereUniqueWithoutUserInput = {
    where: StudySessionWhereUniqueInput
    update: XOR<StudySessionUpdateWithoutUserInput, StudySessionUncheckedUpdateWithoutUserInput>
    create: XOR<StudySessionCreateWithoutUserInput, StudySessionUncheckedCreateWithoutUserInput>
  }

  export type StudySessionUpdateWithWhereUniqueWithoutUserInput = {
    where: StudySessionWhereUniqueInput
    data: XOR<StudySessionUpdateWithoutUserInput, StudySessionUncheckedUpdateWithoutUserInput>
  }

  export type StudySessionUpdateManyWithWhereWithoutUserInput = {
    where: StudySessionScalarWhereInput
    data: XOR<StudySessionUpdateManyMutationInput, StudySessionUncheckedUpdateManyWithoutUserInput>
  }

  export type StudySessionScalarWhereInput = {
    AND?: StudySessionScalarWhereInput | StudySessionScalarWhereInput[]
    OR?: StudySessionScalarWhereInput[]
    NOT?: StudySessionScalarWhereInput | StudySessionScalarWhereInput[]
    id?: StringFilter<"StudySession"> | string
    userId?: StringFilter<"StudySession"> | string
    taskId?: StringNullableFilter<"StudySession"> | string | null
    blockId?: StringNullableFilter<"StudySession"> | string | null
    startedAt?: DateTimeFilter<"StudySession"> | Date | string
    endedAt?: DateTimeNullableFilter<"StudySession"> | Date | string | null
    status?: StringFilter<"StudySession"> | string
    focusedMinutes?: IntFilter<"StudySession"> | number
    xpEarned?: IntFilter<"StudySession"> | number
  }

  export type RewardUpsertWithWhereUniqueWithoutUserInput = {
    where: RewardWhereUniqueInput
    update: XOR<RewardUpdateWithoutUserInput, RewardUncheckedUpdateWithoutUserInput>
    create: XOR<RewardCreateWithoutUserInput, RewardUncheckedCreateWithoutUserInput>
  }

  export type RewardUpdateWithWhereUniqueWithoutUserInput = {
    where: RewardWhereUniqueInput
    data: XOR<RewardUpdateWithoutUserInput, RewardUncheckedUpdateWithoutUserInput>
  }

  export type RewardUpdateManyWithWhereWithoutUserInput = {
    where: RewardScalarWhereInput
    data: XOR<RewardUpdateManyMutationInput, RewardUncheckedUpdateManyWithoutUserInput>
  }

  export type RewardScalarWhereInput = {
    AND?: RewardScalarWhereInput | RewardScalarWhereInput[]
    OR?: RewardScalarWhereInput[]
    NOT?: RewardScalarWhereInput | RewardScalarWhereInput[]
    id?: StringFilter<"Reward"> | string
    userId?: StringFilter<"Reward"> | string
    label?: StringFilter<"Reward"> | string
    detail?: StringNullableFilter<"Reward"> | string | null
    costXp?: IntFilter<"Reward"> | number
    claimedAt?: DateTimeNullableFilter<"Reward"> | Date | string | null
  }

  export type UserStatsUpsertWithoutUserInput = {
    update: XOR<UserStatsUpdateWithoutUserInput, UserStatsUncheckedUpdateWithoutUserInput>
    create: XOR<UserStatsCreateWithoutUserInput, UserStatsUncheckedCreateWithoutUserInput>
    where?: UserStatsWhereInput
  }

  export type UserStatsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserStatsWhereInput
    data: XOR<UserStatsUpdateWithoutUserInput, UserStatsUncheckedUpdateWithoutUserInput>
  }

  export type UserStatsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalXp?: IntFieldUpdateOperationsInput | number
    weeklyXp?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    dailyBaseXp?: IntFieldUpdateOperationsInput | number
    dailyXp?: IntFieldUpdateOperationsInput | number
    dailyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSessionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserStatsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalXp?: IntFieldUpdateOperationsInput | number
    weeklyXp?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    dailyBaseXp?: IntFieldUpdateOperationsInput | number
    dailyXp?: IntFieldUpdateOperationsInput | number
    dailyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSessionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntegrationCanvasUpsertWithoutUserInput = {
    update: XOR<IntegrationCanvasUpdateWithoutUserInput, IntegrationCanvasUncheckedUpdateWithoutUserInput>
    create: XOR<IntegrationCanvasCreateWithoutUserInput, IntegrationCanvasUncheckedCreateWithoutUserInput>
    where?: IntegrationCanvasWhereInput
  }

  export type IntegrationCanvasUpdateToOneWithWhereWithoutUserInput = {
    where?: IntegrationCanvasWhereInput
    data: XOR<IntegrationCanvasUpdateWithoutUserInput, IntegrationCanvasUncheckedUpdateWithoutUserInput>
  }

  export type IntegrationCanvasUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    canvasBaseUrl?: StringFieldUpdateOperationsInput | string
    canvasUserId?: NullableStringFieldUpdateOperationsInput | string | null
    lastImportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationCanvasUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenEncrypted?: NullableStringFieldUpdateOperationsInput | string | null
    canvasBaseUrl?: StringFieldUpdateOperationsInput | string
    canvasUserId?: NullableStringFieldUpdateOperationsInput | string | null
    lastImportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyClassUpsertWithWhereUniqueWithoutUserInput = {
    where: WeeklyClassWhereUniqueInput
    update: XOR<WeeklyClassUpdateWithoutUserInput, WeeklyClassUncheckedUpdateWithoutUserInput>
    create: XOR<WeeklyClassCreateWithoutUserInput, WeeklyClassUncheckedCreateWithoutUserInput>
  }

  export type WeeklyClassUpdateWithWhereUniqueWithoutUserInput = {
    where: WeeklyClassWhereUniqueInput
    data: XOR<WeeklyClassUpdateWithoutUserInput, WeeklyClassUncheckedUpdateWithoutUserInput>
  }

  export type WeeklyClassUpdateManyWithWhereWithoutUserInput = {
    where: WeeklyClassScalarWhereInput
    data: XOR<WeeklyClassUpdateManyMutationInput, WeeklyClassUncheckedUpdateManyWithoutUserInput>
  }

  export type WeeklyClassScalarWhereInput = {
    AND?: WeeklyClassScalarWhereInput | WeeklyClassScalarWhereInput[]
    OR?: WeeklyClassScalarWhereInput[]
    NOT?: WeeklyClassScalarWhereInput | WeeklyClassScalarWhereInput[]
    id?: StringFilter<"WeeklyClass"> | string
    userId?: StringFilter<"WeeklyClass"> | string
    title?: StringFilter<"WeeklyClass"> | string
    day?: IntFilter<"WeeklyClass"> | number
    start?: StringFilter<"WeeklyClass"> | string
    end?: StringFilter<"WeeklyClass"> | string
    location?: StringNullableFilter<"WeeklyClass"> | string | null
    source?: StringFilter<"WeeklyClass"> | string
    externalId?: StringNullableFilter<"WeeklyClass"> | string | null
    createdAt?: DateTimeFilter<"WeeklyClass"> | Date | string
    updatedAt?: DateTimeFilter<"WeeklyClass"> | Date | string
  }

  export type FixedEventUpsertWithWhereUniqueWithoutUserInput = {
    where: FixedEventWhereUniqueInput
    update: XOR<FixedEventUpdateWithoutUserInput, FixedEventUncheckedUpdateWithoutUserInput>
    create: XOR<FixedEventCreateWithoutUserInput, FixedEventUncheckedCreateWithoutUserInput>
  }

  export type FixedEventUpdateWithWhereUniqueWithoutUserInput = {
    where: FixedEventWhereUniqueInput
    data: XOR<FixedEventUpdateWithoutUserInput, FixedEventUncheckedUpdateWithoutUserInput>
  }

  export type FixedEventUpdateManyWithWhereWithoutUserInput = {
    where: FixedEventScalarWhereInput
    data: XOR<FixedEventUpdateManyMutationInput, FixedEventUncheckedUpdateManyWithoutUserInput>
  }

  export type FixedEventScalarWhereInput = {
    AND?: FixedEventScalarWhereInput | FixedEventScalarWhereInput[]
    OR?: FixedEventScalarWhereInput[]
    NOT?: FixedEventScalarWhereInput | FixedEventScalarWhereInput[]
    id?: StringFilter<"FixedEvent"> | string
    userId?: StringFilter<"FixedEvent"> | string
    title?: StringFilter<"FixedEvent"> | string
    type?: StringFilter<"FixedEvent"> | string
    start?: DateTimeFilter<"FixedEvent"> | Date | string
    end?: DateTimeFilter<"FixedEvent"> | Date | string
    notes?: StringNullableFilter<"FixedEvent"> | string | null
    source?: StringFilter<"FixedEvent"> | string
    externalId?: StringNullableFilter<"FixedEvent"> | string | null
    createdAt?: DateTimeFilter<"FixedEvent"> | Date | string
    updatedAt?: DateTimeFilter<"FixedEvent"> | Date | string
  }

  export type UserCreateWithoutTasksInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studyBlocks?: StudyBlockCreateNestedManyWithoutUserInput
    studySessions?: StudySessionCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
    integrationCanvas?: IntegrationCanvasCreateNestedOneWithoutUserInput
    weeklyClasses?: WeeklyClassCreateNestedManyWithoutUserInput
    fixedEvents?: FixedEventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTasksInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studyBlocks?: StudyBlockUncheckedCreateNestedManyWithoutUserInput
    studySessions?: StudySessionUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
    integrationCanvas?: IntegrationCanvasUncheckedCreateNestedOneWithoutUserInput
    weeklyClasses?: WeeklyClassUncheckedCreateNestedManyWithoutUserInput
    fixedEvents?: FixedEventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
  }

  export type StudyBlockCreateWithoutTaskInput = {
    id?: string
    start: Date | string
    end: Date | string
    source?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudyBlocksInput
    studySession?: StudySessionCreateNestedOneWithoutBlockInput
  }

  export type StudyBlockUncheckedCreateWithoutTaskInput = {
    id?: string
    userId: string
    start: Date | string
    end: Date | string
    source?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studySession?: StudySessionUncheckedCreateNestedOneWithoutBlockInput
  }

  export type StudyBlockCreateOrConnectWithoutTaskInput = {
    where: StudyBlockWhereUniqueInput
    create: XOR<StudyBlockCreateWithoutTaskInput, StudyBlockUncheckedCreateWithoutTaskInput>
  }

  export type StudyBlockCreateManyTaskInputEnvelope = {
    data: StudyBlockCreateManyTaskInput | StudyBlockCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type StudySessionCreateWithoutTaskInput = {
    id?: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: string
    focusedMinutes?: number
    xpEarned?: number
    user: UserCreateNestedOneWithoutStudySessionsInput
    block?: StudyBlockCreateNestedOneWithoutStudySessionInput
  }

  export type StudySessionUncheckedCreateWithoutTaskInput = {
    id?: string
    userId: string
    blockId?: string | null
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: string
    focusedMinutes?: number
    xpEarned?: number
  }

  export type StudySessionCreateOrConnectWithoutTaskInput = {
    where: StudySessionWhereUniqueInput
    create: XOR<StudySessionCreateWithoutTaskInput, StudySessionUncheckedCreateWithoutTaskInput>
  }

  export type StudySessionCreateManyTaskInputEnvelope = {
    data: StudySessionCreateManyTaskInput | StudySessionCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTasksInput = {
    update: XOR<UserUpdateWithoutTasksInput, UserUncheckedUpdateWithoutTasksInput>
    create: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTasksInput, UserUncheckedUpdateWithoutTasksInput>
  }

  export type UserUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studyBlocks?: StudyBlockUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
    integrationCanvas?: IntegrationCanvasUpdateOneWithoutUserNestedInput
    weeklyClasses?: WeeklyClassUpdateManyWithoutUserNestedInput
    fixedEvents?: FixedEventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studyBlocks?: StudyBlockUncheckedUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
    integrationCanvas?: IntegrationCanvasUncheckedUpdateOneWithoutUserNestedInput
    weeklyClasses?: WeeklyClassUncheckedUpdateManyWithoutUserNestedInput
    fixedEvents?: FixedEventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StudyBlockUpsertWithWhereUniqueWithoutTaskInput = {
    where: StudyBlockWhereUniqueInput
    update: XOR<StudyBlockUpdateWithoutTaskInput, StudyBlockUncheckedUpdateWithoutTaskInput>
    create: XOR<StudyBlockCreateWithoutTaskInput, StudyBlockUncheckedCreateWithoutTaskInput>
  }

  export type StudyBlockUpdateWithWhereUniqueWithoutTaskInput = {
    where: StudyBlockWhereUniqueInput
    data: XOR<StudyBlockUpdateWithoutTaskInput, StudyBlockUncheckedUpdateWithoutTaskInput>
  }

  export type StudyBlockUpdateManyWithWhereWithoutTaskInput = {
    where: StudyBlockScalarWhereInput
    data: XOR<StudyBlockUpdateManyMutationInput, StudyBlockUncheckedUpdateManyWithoutTaskInput>
  }

  export type StudySessionUpsertWithWhereUniqueWithoutTaskInput = {
    where: StudySessionWhereUniqueInput
    update: XOR<StudySessionUpdateWithoutTaskInput, StudySessionUncheckedUpdateWithoutTaskInput>
    create: XOR<StudySessionCreateWithoutTaskInput, StudySessionUncheckedCreateWithoutTaskInput>
  }

  export type StudySessionUpdateWithWhereUniqueWithoutTaskInput = {
    where: StudySessionWhereUniqueInput
    data: XOR<StudySessionUpdateWithoutTaskInput, StudySessionUncheckedUpdateWithoutTaskInput>
  }

  export type StudySessionUpdateManyWithWhereWithoutTaskInput = {
    where: StudySessionScalarWhereInput
    data: XOR<StudySessionUpdateManyMutationInput, StudySessionUncheckedUpdateManyWithoutTaskInput>
  }

  export type UserCreateWithoutStudyBlocksInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskCreateNestedManyWithoutUserInput
    studySessions?: StudySessionCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
    integrationCanvas?: IntegrationCanvasCreateNestedOneWithoutUserInput
    weeklyClasses?: WeeklyClassCreateNestedManyWithoutUserInput
    fixedEvents?: FixedEventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStudyBlocksInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    studySessions?: StudySessionUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
    integrationCanvas?: IntegrationCanvasUncheckedCreateNestedOneWithoutUserInput
    weeklyClasses?: WeeklyClassUncheckedCreateNestedManyWithoutUserInput
    fixedEvents?: FixedEventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStudyBlocksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudyBlocksInput, UserUncheckedCreateWithoutStudyBlocksInput>
  }

  export type TaskCreateWithoutStudyBlocksInput = {
    id?: string
    title: string
    description?: string | null
    deadline?: Date | string | null
    difficulty?: string
    priority?: number
    remainingHours?: number
    status?: string
    source?: string
    externalId?: string | null
    completedAt?: Date | string | null
    completionXpAwarded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTasksInput
    studySessions?: StudySessionCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutStudyBlocksInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    deadline?: Date | string | null
    difficulty?: string
    priority?: number
    remainingHours?: number
    status?: string
    source?: string
    externalId?: string | null
    completedAt?: Date | string | null
    completionXpAwarded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studySessions?: StudySessionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutStudyBlocksInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutStudyBlocksInput, TaskUncheckedCreateWithoutStudyBlocksInput>
  }

  export type StudySessionCreateWithoutBlockInput = {
    id?: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: string
    focusedMinutes?: number
    xpEarned?: number
    user: UserCreateNestedOneWithoutStudySessionsInput
    task?: TaskCreateNestedOneWithoutStudySessionsInput
  }

  export type StudySessionUncheckedCreateWithoutBlockInput = {
    id?: string
    userId: string
    taskId?: string | null
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: string
    focusedMinutes?: number
    xpEarned?: number
  }

  export type StudySessionCreateOrConnectWithoutBlockInput = {
    where: StudySessionWhereUniqueInput
    create: XOR<StudySessionCreateWithoutBlockInput, StudySessionUncheckedCreateWithoutBlockInput>
  }

  export type UserUpsertWithoutStudyBlocksInput = {
    update: XOR<UserUpdateWithoutStudyBlocksInput, UserUncheckedUpdateWithoutStudyBlocksInput>
    create: XOR<UserCreateWithoutStudyBlocksInput, UserUncheckedCreateWithoutStudyBlocksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudyBlocksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudyBlocksInput, UserUncheckedUpdateWithoutStudyBlocksInput>
  }

  export type UserUpdateWithoutStudyBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
    integrationCanvas?: IntegrationCanvasUpdateOneWithoutUserNestedInput
    weeklyClasses?: WeeklyClassUpdateManyWithoutUserNestedInput
    fixedEvents?: FixedEventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStudyBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
    integrationCanvas?: IntegrationCanvasUncheckedUpdateOneWithoutUserNestedInput
    weeklyClasses?: WeeklyClassUncheckedUpdateManyWithoutUserNestedInput
    fixedEvents?: FixedEventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TaskUpsertWithoutStudyBlocksInput = {
    update: XOR<TaskUpdateWithoutStudyBlocksInput, TaskUncheckedUpdateWithoutStudyBlocksInput>
    create: XOR<TaskCreateWithoutStudyBlocksInput, TaskUncheckedCreateWithoutStudyBlocksInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutStudyBlocksInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutStudyBlocksInput, TaskUncheckedUpdateWithoutStudyBlocksInput>
  }

  export type TaskUpdateWithoutStudyBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    remainingHours?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionXpAwarded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
    studySessions?: StudySessionUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutStudyBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    remainingHours?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionXpAwarded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studySessions?: StudySessionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type StudySessionUpsertWithoutBlockInput = {
    update: XOR<StudySessionUpdateWithoutBlockInput, StudySessionUncheckedUpdateWithoutBlockInput>
    create: XOR<StudySessionCreateWithoutBlockInput, StudySessionUncheckedCreateWithoutBlockInput>
    where?: StudySessionWhereInput
  }

  export type StudySessionUpdateToOneWithWhereWithoutBlockInput = {
    where?: StudySessionWhereInput
    data: XOR<StudySessionUpdateWithoutBlockInput, StudySessionUncheckedUpdateWithoutBlockInput>
  }

  export type StudySessionUpdateWithoutBlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    focusedMinutes?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutStudySessionsNestedInput
    task?: TaskUpdateOneWithoutStudySessionsNestedInput
  }

  export type StudySessionUncheckedUpdateWithoutBlockInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    focusedMinutes?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateWithoutStudySessionsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskCreateNestedManyWithoutUserInput
    studyBlocks?: StudyBlockCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
    integrationCanvas?: IntegrationCanvasCreateNestedOneWithoutUserInput
    weeklyClasses?: WeeklyClassCreateNestedManyWithoutUserInput
    fixedEvents?: FixedEventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStudySessionsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    studyBlocks?: StudyBlockUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
    integrationCanvas?: IntegrationCanvasUncheckedCreateNestedOneWithoutUserInput
    weeklyClasses?: WeeklyClassUncheckedCreateNestedManyWithoutUserInput
    fixedEvents?: FixedEventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStudySessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudySessionsInput, UserUncheckedCreateWithoutStudySessionsInput>
  }

  export type TaskCreateWithoutStudySessionsInput = {
    id?: string
    title: string
    description?: string | null
    deadline?: Date | string | null
    difficulty?: string
    priority?: number
    remainingHours?: number
    status?: string
    source?: string
    externalId?: string | null
    completedAt?: Date | string | null
    completionXpAwarded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTasksInput
    studyBlocks?: StudyBlockCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutStudySessionsInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    deadline?: Date | string | null
    difficulty?: string
    priority?: number
    remainingHours?: number
    status?: string
    source?: string
    externalId?: string | null
    completedAt?: Date | string | null
    completionXpAwarded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studyBlocks?: StudyBlockUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutStudySessionsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutStudySessionsInput, TaskUncheckedCreateWithoutStudySessionsInput>
  }

  export type StudyBlockCreateWithoutStudySessionInput = {
    id?: string
    start: Date | string
    end: Date | string
    source?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudyBlocksInput
    task?: TaskCreateNestedOneWithoutStudyBlocksInput
  }

  export type StudyBlockUncheckedCreateWithoutStudySessionInput = {
    id?: string
    userId: string
    taskId?: string | null
    start: Date | string
    end: Date | string
    source?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudyBlockCreateOrConnectWithoutStudySessionInput = {
    where: StudyBlockWhereUniqueInput
    create: XOR<StudyBlockCreateWithoutStudySessionInput, StudyBlockUncheckedCreateWithoutStudySessionInput>
  }

  export type UserUpsertWithoutStudySessionsInput = {
    update: XOR<UserUpdateWithoutStudySessionsInput, UserUncheckedUpdateWithoutStudySessionsInput>
    create: XOR<UserCreateWithoutStudySessionsInput, UserUncheckedCreateWithoutStudySessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudySessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudySessionsInput, UserUncheckedUpdateWithoutStudySessionsInput>
  }

  export type UserUpdateWithoutStudySessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutUserNestedInput
    studyBlocks?: StudyBlockUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
    integrationCanvas?: IntegrationCanvasUpdateOneWithoutUserNestedInput
    weeklyClasses?: WeeklyClassUpdateManyWithoutUserNestedInput
    fixedEvents?: FixedEventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStudySessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    studyBlocks?: StudyBlockUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
    integrationCanvas?: IntegrationCanvasUncheckedUpdateOneWithoutUserNestedInput
    weeklyClasses?: WeeklyClassUncheckedUpdateManyWithoutUserNestedInput
    fixedEvents?: FixedEventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TaskUpsertWithoutStudySessionsInput = {
    update: XOR<TaskUpdateWithoutStudySessionsInput, TaskUncheckedUpdateWithoutStudySessionsInput>
    create: XOR<TaskCreateWithoutStudySessionsInput, TaskUncheckedCreateWithoutStudySessionsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutStudySessionsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutStudySessionsInput, TaskUncheckedUpdateWithoutStudySessionsInput>
  }

  export type TaskUpdateWithoutStudySessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    remainingHours?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionXpAwarded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
    studyBlocks?: StudyBlockUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutStudySessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    remainingHours?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionXpAwarded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studyBlocks?: StudyBlockUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type StudyBlockUpsertWithoutStudySessionInput = {
    update: XOR<StudyBlockUpdateWithoutStudySessionInput, StudyBlockUncheckedUpdateWithoutStudySessionInput>
    create: XOR<StudyBlockCreateWithoutStudySessionInput, StudyBlockUncheckedCreateWithoutStudySessionInput>
    where?: StudyBlockWhereInput
  }

  export type StudyBlockUpdateToOneWithWhereWithoutStudySessionInput = {
    where?: StudyBlockWhereInput
    data: XOR<StudyBlockUpdateWithoutStudySessionInput, StudyBlockUncheckedUpdateWithoutStudySessionInput>
  }

  export type StudyBlockUpdateWithoutStudySessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudyBlocksNestedInput
    task?: TaskUpdateOneWithoutStudyBlocksNestedInput
  }

  export type StudyBlockUncheckedUpdateWithoutStudySessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutRewardsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskCreateNestedManyWithoutUserInput
    studyBlocks?: StudyBlockCreateNestedManyWithoutUserInput
    studySessions?: StudySessionCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
    integrationCanvas?: IntegrationCanvasCreateNestedOneWithoutUserInput
    weeklyClasses?: WeeklyClassCreateNestedManyWithoutUserInput
    fixedEvents?: FixedEventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRewardsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    studyBlocks?: StudyBlockUncheckedCreateNestedManyWithoutUserInput
    studySessions?: StudySessionUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
    integrationCanvas?: IntegrationCanvasUncheckedCreateNestedOneWithoutUserInput
    weeklyClasses?: WeeklyClassUncheckedCreateNestedManyWithoutUserInput
    fixedEvents?: FixedEventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRewardsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRewardsInput, UserUncheckedCreateWithoutRewardsInput>
  }

  export type UserUpsertWithoutRewardsInput = {
    update: XOR<UserUpdateWithoutRewardsInput, UserUncheckedUpdateWithoutRewardsInput>
    create: XOR<UserCreateWithoutRewardsInput, UserUncheckedCreateWithoutRewardsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRewardsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRewardsInput, UserUncheckedUpdateWithoutRewardsInput>
  }

  export type UserUpdateWithoutRewardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutUserNestedInput
    studyBlocks?: StudyBlockUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
    integrationCanvas?: IntegrationCanvasUpdateOneWithoutUserNestedInput
    weeklyClasses?: WeeklyClassUpdateManyWithoutUserNestedInput
    fixedEvents?: FixedEventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRewardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    studyBlocks?: StudyBlockUncheckedUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
    integrationCanvas?: IntegrationCanvasUncheckedUpdateOneWithoutUserNestedInput
    weeklyClasses?: WeeklyClassUncheckedUpdateManyWithoutUserNestedInput
    fixedEvents?: FixedEventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutStatsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskCreateNestedManyWithoutUserInput
    studyBlocks?: StudyBlockCreateNestedManyWithoutUserInput
    studySessions?: StudySessionCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    integrationCanvas?: IntegrationCanvasCreateNestedOneWithoutUserInput
    weeklyClasses?: WeeklyClassCreateNestedManyWithoutUserInput
    fixedEvents?: FixedEventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStatsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    studyBlocks?: StudyBlockUncheckedCreateNestedManyWithoutUserInput
    studySessions?: StudySessionUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    integrationCanvas?: IntegrationCanvasUncheckedCreateNestedOneWithoutUserInput
    weeklyClasses?: WeeklyClassUncheckedCreateNestedManyWithoutUserInput
    fixedEvents?: FixedEventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStatsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStatsInput, UserUncheckedCreateWithoutStatsInput>
  }

  export type UserUpsertWithoutStatsInput = {
    update: XOR<UserUpdateWithoutStatsInput, UserUncheckedUpdateWithoutStatsInput>
    create: XOR<UserCreateWithoutStatsInput, UserUncheckedCreateWithoutStatsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStatsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStatsInput, UserUncheckedUpdateWithoutStatsInput>
  }

  export type UserUpdateWithoutStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutUserNestedInput
    studyBlocks?: StudyBlockUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    integrationCanvas?: IntegrationCanvasUpdateOneWithoutUserNestedInput
    weeklyClasses?: WeeklyClassUpdateManyWithoutUserNestedInput
    fixedEvents?: FixedEventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    studyBlocks?: StudyBlockUncheckedUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    integrationCanvas?: IntegrationCanvasUncheckedUpdateOneWithoutUserNestedInput
    weeklyClasses?: WeeklyClassUncheckedUpdateManyWithoutUserNestedInput
    fixedEvents?: FixedEventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutIntegrationCanvasInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskCreateNestedManyWithoutUserInput
    studyBlocks?: StudyBlockCreateNestedManyWithoutUserInput
    studySessions?: StudySessionCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
    weeklyClasses?: WeeklyClassCreateNestedManyWithoutUserInput
    fixedEvents?: FixedEventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIntegrationCanvasInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    studyBlocks?: StudyBlockUncheckedCreateNestedManyWithoutUserInput
    studySessions?: StudySessionUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
    weeklyClasses?: WeeklyClassUncheckedCreateNestedManyWithoutUserInput
    fixedEvents?: FixedEventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIntegrationCanvasInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIntegrationCanvasInput, UserUncheckedCreateWithoutIntegrationCanvasInput>
  }

  export type UserUpsertWithoutIntegrationCanvasInput = {
    update: XOR<UserUpdateWithoutIntegrationCanvasInput, UserUncheckedUpdateWithoutIntegrationCanvasInput>
    create: XOR<UserCreateWithoutIntegrationCanvasInput, UserUncheckedCreateWithoutIntegrationCanvasInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIntegrationCanvasInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIntegrationCanvasInput, UserUncheckedUpdateWithoutIntegrationCanvasInput>
  }

  export type UserUpdateWithoutIntegrationCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutUserNestedInput
    studyBlocks?: StudyBlockUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
    weeklyClasses?: WeeklyClassUpdateManyWithoutUserNestedInput
    fixedEvents?: FixedEventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutIntegrationCanvasInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    studyBlocks?: StudyBlockUncheckedUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
    weeklyClasses?: WeeklyClassUncheckedUpdateManyWithoutUserNestedInput
    fixedEvents?: FixedEventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutFixedEventsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskCreateNestedManyWithoutUserInput
    studyBlocks?: StudyBlockCreateNestedManyWithoutUserInput
    studySessions?: StudySessionCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
    integrationCanvas?: IntegrationCanvasCreateNestedOneWithoutUserInput
    weeklyClasses?: WeeklyClassCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFixedEventsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    studyBlocks?: StudyBlockUncheckedCreateNestedManyWithoutUserInput
    studySessions?: StudySessionUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
    integrationCanvas?: IntegrationCanvasUncheckedCreateNestedOneWithoutUserInput
    weeklyClasses?: WeeklyClassUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFixedEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFixedEventsInput, UserUncheckedCreateWithoutFixedEventsInput>
  }

  export type UserUpsertWithoutFixedEventsInput = {
    update: XOR<UserUpdateWithoutFixedEventsInput, UserUncheckedUpdateWithoutFixedEventsInput>
    create: XOR<UserCreateWithoutFixedEventsInput, UserUncheckedCreateWithoutFixedEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFixedEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFixedEventsInput, UserUncheckedUpdateWithoutFixedEventsInput>
  }

  export type UserUpdateWithoutFixedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutUserNestedInput
    studyBlocks?: StudyBlockUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
    integrationCanvas?: IntegrationCanvasUpdateOneWithoutUserNestedInput
    weeklyClasses?: WeeklyClassUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFixedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    studyBlocks?: StudyBlockUncheckedUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
    integrationCanvas?: IntegrationCanvasUncheckedUpdateOneWithoutUserNestedInput
    weeklyClasses?: WeeklyClassUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutWeeklyClassesInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskCreateNestedManyWithoutUserInput
    studyBlocks?: StudyBlockCreateNestedManyWithoutUserInput
    studySessions?: StudySessionCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
    integrationCanvas?: IntegrationCanvasCreateNestedOneWithoutUserInput
    fixedEvents?: FixedEventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWeeklyClassesInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    studyBlocks?: StudyBlockUncheckedCreateNestedManyWithoutUserInput
    studySessions?: StudySessionUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
    integrationCanvas?: IntegrationCanvasUncheckedCreateNestedOneWithoutUserInput
    fixedEvents?: FixedEventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWeeklyClassesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWeeklyClassesInput, UserUncheckedCreateWithoutWeeklyClassesInput>
  }

  export type UserUpsertWithoutWeeklyClassesInput = {
    update: XOR<UserUpdateWithoutWeeklyClassesInput, UserUncheckedUpdateWithoutWeeklyClassesInput>
    create: XOR<UserCreateWithoutWeeklyClassesInput, UserUncheckedCreateWithoutWeeklyClassesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWeeklyClassesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWeeklyClassesInput, UserUncheckedUpdateWithoutWeeklyClassesInput>
  }

  export type UserUpdateWithoutWeeklyClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutUserNestedInput
    studyBlocks?: StudyBlockUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
    integrationCanvas?: IntegrationCanvasUpdateOneWithoutUserNestedInput
    fixedEvents?: FixedEventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWeeklyClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    studyBlocks?: StudyBlockUncheckedUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
    integrationCanvas?: IntegrationCanvasUncheckedUpdateOneWithoutUserNestedInput
    fixedEvents?: FixedEventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TaskCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    deadline?: Date | string | null
    difficulty?: string
    priority?: number
    remainingHours?: number
    status?: string
    source?: string
    externalId?: string | null
    completedAt?: Date | string | null
    completionXpAwarded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudyBlockCreateManyUserInput = {
    id?: string
    taskId?: string | null
    start: Date | string
    end: Date | string
    source?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudySessionCreateManyUserInput = {
    id?: string
    taskId?: string | null
    blockId?: string | null
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: string
    focusedMinutes?: number
    xpEarned?: number
  }

  export type RewardCreateManyUserInput = {
    id?: string
    label: string
    detail?: string | null
    costXp?: number
    claimedAt?: Date | string | null
  }

  export type WeeklyClassCreateManyUserInput = {
    id?: string
    title: string
    day: number
    start: string
    end: string
    location?: string | null
    source?: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FixedEventCreateManyUserInput = {
    id?: string
    title: string
    type?: string
    start: Date | string
    end: Date | string
    notes?: string | null
    source?: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    remainingHours?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionXpAwarded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studyBlocks?: StudyBlockUpdateManyWithoutTaskNestedInput
    studySessions?: StudySessionUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    remainingHours?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionXpAwarded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studyBlocks?: StudyBlockUncheckedUpdateManyWithoutTaskNestedInput
    studySessions?: StudySessionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    remainingHours?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionXpAwarded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyBlockUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneWithoutStudyBlocksNestedInput
    studySession?: StudySessionUpdateOneWithoutBlockNestedInput
  }

  export type StudyBlockUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studySession?: StudySessionUncheckedUpdateOneWithoutBlockNestedInput
  }

  export type StudyBlockUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudySessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    focusedMinutes?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    task?: TaskUpdateOneWithoutStudySessionsNestedInput
    block?: StudyBlockUpdateOneWithoutStudySessionNestedInput
  }

  export type StudySessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    blockId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    focusedMinutes?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
  }

  export type StudySessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    blockId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    focusedMinutes?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
  }

  export type RewardUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    costXp?: IntFieldUpdateOperationsInput | number
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RewardUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    costXp?: IntFieldUpdateOperationsInput | number
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RewardUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    costXp?: IntFieldUpdateOperationsInput | number
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WeeklyClassUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    day?: IntFieldUpdateOperationsInput | number
    start?: StringFieldUpdateOperationsInput | string
    end?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyClassUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    day?: IntFieldUpdateOperationsInput | number
    start?: StringFieldUpdateOperationsInput | string
    end?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyClassUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    day?: IntFieldUpdateOperationsInput | number
    start?: StringFieldUpdateOperationsInput | string
    end?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FixedEventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FixedEventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FixedEventUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyBlockCreateManyTaskInput = {
    id?: string
    userId: string
    start: Date | string
    end: Date | string
    source?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudySessionCreateManyTaskInput = {
    id?: string
    userId: string
    blockId?: string | null
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: string
    focusedMinutes?: number
    xpEarned?: number
  }

  export type StudyBlockUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudyBlocksNestedInput
    studySession?: StudySessionUpdateOneWithoutBlockNestedInput
  }

  export type StudyBlockUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studySession?: StudySessionUncheckedUpdateOneWithoutBlockNestedInput
  }

  export type StudyBlockUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudySessionUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    focusedMinutes?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutStudySessionsNestedInput
    block?: StudyBlockUpdateOneWithoutStudySessionNestedInput
  }

  export type StudySessionUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    blockId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    focusedMinutes?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
  }

  export type StudySessionUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    blockId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    focusedMinutes?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}